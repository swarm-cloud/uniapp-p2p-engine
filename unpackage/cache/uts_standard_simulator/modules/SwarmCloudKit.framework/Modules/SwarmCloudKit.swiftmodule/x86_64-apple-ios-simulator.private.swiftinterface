// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9 (swiftlang-5.9.0.128.108 clang-1500.0.40.1)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SwarmCloudKit
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import CryptoKit
import Dispatch
import Foundation
import MobileCoreServices
import Network
@_exported import SwarmCloudKit
import Swift
import SystemConfiguration
import UIKit
import UniformTypeIdentifiers
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import datachannel_wrapper
import zlib
@_inheritsConvenienceInitializers open class MasterPlaylist : SwarmCloudKit.HlsPlaylist {
  override public init()
  open func addPlaylist(_ playlist: SwarmCloudKit.MediaPlaylist)
  open func getPlaylist(_ index: Swift.Int) -> SwarmCloudKit.MediaPlaylist?
  open func getPlaylistCount() -> Swift.Int
  open func getPlaylists() -> [SwarmCloudKit.MediaPlaylist]
  @objc deinit
}
extension SwarmCloudKit.MasterPlaylist : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct StunChangeRequest {
  public var changeIp: Swift.Bool {
    get
  }
  public var changePort: Swift.Bool {
    get
  }
}
public protocol BufferedReader {
  func close()
  func readLine() -> Swift.String?
  func reset()
}
public class AsyncStorage<Key, Value> where Key : Swift.Hashable {
  final public let innerStorage: SwarmCloudKit.HybridStorage<Key, Value>
  final public let serialQueue: Dispatch.DispatchQueue
  public init(storage: SwarmCloudKit.HybridStorage<Key, Value>, serialQueue: Dispatch.DispatchQueue)
  @objc deinit
}
extension SwarmCloudKit.AsyncStorage {
  public func entry(forKey key: Key, completion: @escaping (Swift.Result<SwarmCloudKit.Entry<Value>, any Swift.Error>) -> Swift.Void)
  public func removeObject(forKey key: Key, completion: @escaping (Swift.Result<(), any Swift.Error>) -> Swift.Void)
  public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil, completion: @escaping (Swift.Result<(), any Swift.Error>) -> Swift.Void)
  public func removeAll(completion: @escaping (Swift.Result<(), any Swift.Error>) -> Swift.Void)
  public func removeExpiredObjects(completion: @escaping (Swift.Result<(), any Swift.Error>) -> Swift.Void)
  public func object(forKey key: Key, completion: @escaping (Swift.Result<Value, any Swift.Error>) -> Swift.Void)
  @available(*, deprecated, renamed: "objectExists(forKey:completion:)")
  public func existsObject(forKey key: Key, completion: @escaping (Swift.Result<Swift.Bool, any Swift.Error>) -> Swift.Void)
  public func objectExists(forKey key: Key, completion: @escaping (Swift.Result<Swift.Bool, any Swift.Error>) -> Swift.Void)
}
extension SwarmCloudKit.AsyncStorage {
  public func transform<U>(transformer: SwarmCloudKit.Transformer<U>) -> SwarmCloudKit.AsyncStorage<Key, U>
}
public struct HTTPHeaders {
  public init()
  public init(_ headers: [SwarmCloudKit.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: SwarmCloudKit.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: SwarmCloudKit.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> SwarmCloudKit.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension SwarmCloudKit.HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension SwarmCloudKit.HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: SwarmCloudKit.HTTPHeader...)
  public typealias ArrayLiteralElement = SwarmCloudKit.HTTPHeader
}
extension SwarmCloudKit.HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[SwarmCloudKit.HTTPHeader]>
}
extension SwarmCloudKit.HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> SwarmCloudKit.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = SwarmCloudKit.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<SwarmCloudKit.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[SwarmCloudKit.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<SwarmCloudKit.HTTPHeaders>
}
extension SwarmCloudKit.HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SwarmCloudKit.HTTPHeader, b: SwarmCloudKit.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SwarmCloudKit.HTTPHeader {
  public static func accept(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func authorization(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func contentEncoding(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func contentType(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> SwarmCloudKit.HTTPHeader
}
extension SwarmCloudKit.HTTPHeaders {
  public static let `default`: SwarmCloudKit.HTTPHeaders
}
extension SwarmCloudKit.HTTPHeader {
  public static let defaultAcceptEncoding: SwarmCloudKit.HTTPHeader
  public static let defaultAcceptLanguage: SwarmCloudKit.HTTPHeader
  public static let defaultUserAgent: SwarmCloudKit.HTTPHeader
}
extension Foundation.URLRequest {
  public var headers: SwarmCloudKit.HTTPHeaders {
    get
    set
  }
}
extension Foundation.HTTPURLResponse {
  public var headers: SwarmCloudKit.HTTPHeaders {
    get
  }
}
extension Foundation.URLSessionConfiguration {
  public var headers: SwarmCloudKit.HTTPHeaders {
    get
    set
  }
}
@_hasMissingDesignatedInitializers final public class ObservationToken {
  final public func cancel()
  @objc deinit
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding, b: SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public struct KeyPathEncoding {
    public static let brackets: SwarmCloudKit.URLEncodedFormEncoder.KeyPathEncoding
    public static let dots: SwarmCloudKit.URLEncodedFormEncoder.KeyPathEncoding
    public init(encoding: @escaping (_ subkey: Swift.String) -> Swift.String)
  }
  public struct NilEncoding {
    public static let dropKey: SwarmCloudKit.URLEncodedFormEncoder.NilEncoding
    public static let dropValue: SwarmCloudKit.URLEncodedFormEncoder.NilEncoding
    public static let null: SwarmCloudKit.URLEncodedFormEncoder.NilEncoding
    public init(encoding: @escaping () -> Swift.String?)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding, b: SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: SwarmCloudKit.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: SwarmCloudKit.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: SwarmCloudKit.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: SwarmCloudKit.URLEncodedFormEncoder.KeyEncoding
  final public let keyPathEncoding: SwarmCloudKit.URLEncodedFormEncoder.KeyPathEncoding
  final public let nilEncoding: SwarmCloudKit.URLEncodedFormEncoder.NilEncoding
  final public let spaceEncoding: SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: SwarmCloudKit.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: SwarmCloudKit.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: SwarmCloudKit.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: SwarmCloudKit.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, keyPathEncoding: SwarmCloudKit.URLEncodedFormEncoder.KeyPathEncoding = .brackets, nilEncoding: SwarmCloudKit.URLEncodedFormEncoder.NilEncoding = .dropKey, spaceEncoding: SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: any Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: any Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension Foundation.CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
public struct StunResult {
  public var natType: SwarmCloudKit.NatType {
    get
  }
  public var ipAddr: SwarmCloudKit.SocketAddress? {
    get
  }
}
public enum SerializationError : Swift.Error {
  case invalidObject
  case notSupported
  public static func == (a: SwarmCloudKit.SerializationError, b: SwarmCloudKit.SerializationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol HttpResponseBodyWriter {
  func write(_ data: [Swift.UInt8]) throws
  func write(_ data: Swift.ArraySlice<Swift.UInt8>) throws
  func write(_ data: Foundation.NSData) throws
  func write(_ data: Foundation.Data) throws
}
public enum HttpResponseBody {
  case json(Any)
  case html(Swift.String)
  case htmlBody(Swift.String)
  case text(Swift.String)
  case data(Foundation.Data, contentType: Swift.String? = nil)
  case custom(Any, (Any) throws -> Swift.String)
}
public enum HttpResponse {
  case switchProtocols([Swift.String : Swift.String], (SwarmCloudKit.Socket) -> Swift.Void)
  case ok(SwarmCloudKit.HttpResponseBody, _: [Swift.String : Swift.String] = [:]), created, accepted
  case movedPermanently(Swift.String)
  case movedTemporarily(Swift.String)
  case badRequest(SwarmCloudKit.HttpResponseBody?), unauthorized(SwarmCloudKit.HttpResponseBody?), forbidden(SwarmCloudKit.HttpResponseBody?), notFound(_: SwarmCloudKit.HttpResponseBody? = nil), notAcceptable(SwarmCloudKit.HttpResponseBody?), tooManyRequests(SwarmCloudKit.HttpResponseBody?), internalServerError(SwarmCloudKit.HttpResponseBody?)
  case raw(Swift.Int, Swift.String, [Swift.String : Swift.String]?, ((any SwarmCloudKit.HttpResponseBodyWriter) throws -> Swift.Void)?)
  public var statusCode: Swift.Int {
    get
  }
  public var reasonPhrase: Swift.String {
    get
  }
  public func headers() -> [Swift.String : Swift.String]
}
@objc public enum TrackerZone : Swift.Int {
  case Europe = 0
  case HongKong
  case USA
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct StunErrorCode {
  public var code: Swift.Int {
    get
  }
  public var reasonText: Swift.String {
    get
  }
}
public struct TypeWrapper<T> : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  public let object: T
  public init(object: T)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum StorageError : Swift.Error {
  case notFound
  case typeNotMatch
  case malformedFileAttributes
  case decodingFailed
  case encodingFailed
  case deallocated
  case transformerFail
  public static func == (a: SwarmCloudKit.StorageError, b: SwarmCloudKit.StorageError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : SwarmCloudKit.ParameterEncoder {
  public static var `default`: SwarmCloudKit.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: SwarmCloudKit.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: SwarmCloudKit.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension SwarmCloudKit.ParameterEncoder where Self == SwarmCloudKit.JSONParameterEncoder {
  public static var json: SwarmCloudKit.JSONParameterEncoder {
    get
  }
  public static func json(encoder: Foundation.JSONEncoder = JSONEncoder()) -> SwarmCloudKit.JSONParameterEncoder
}
open class URLEncodedFormParameterEncoder : SwarmCloudKit.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SwarmCloudKit.URLEncodedFormParameterEncoder.Destination, b: SwarmCloudKit.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SwarmCloudKit.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: SwarmCloudKit.URLEncodedFormEncoder
  final public let destination: SwarmCloudKit.URLEncodedFormParameterEncoder.Destination
  public init(encoder: SwarmCloudKit.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: SwarmCloudKit.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
extension SwarmCloudKit.ParameterEncoder where Self == SwarmCloudKit.URLEncodedFormParameterEncoder {
  public static var urlEncodedForm: SwarmCloudKit.URLEncodedFormParameterEncoder {
    get
  }
  public static func urlEncodedForm(encoder: SwarmCloudKit.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: SwarmCloudKit.URLEncodedFormParameterEncoder.Destination = .methodDependent) -> SwarmCloudKit.URLEncodedFormParameterEncoder
}
public struct SocketAddress {
  public var ip: Swift.String {
    get
  }
  public var port: Swift.Int {
    get
  }
}
extension Swift.String {
  public func toUint8Array() -> [Swift.UInt8]
}
extension Swift.UInt32 {
  public func IPv4String() -> Swift.String
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : any SwarmCloudKit.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : any SwarmCloudKit.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> (any SwarmCloudKit.ServerTrustEvaluating)?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: SwarmCloudKit.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: SwarmCloudKit.RevocationTrustEvaluator.Options
    public static let ocsp: SwarmCloudKit.RevocationTrustEvaluator.Options
    public static let preferCRL: SwarmCloudKit.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: SwarmCloudKit.RevocationTrustEvaluator.Options
    public static let any: SwarmCloudKit.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = SwarmCloudKit.RevocationTrustEvaluator.Options
    public typealias Element = SwarmCloudKit.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: SwarmCloudKit.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SwarmCloudKit.ServerTrustEvaluating where Self == SwarmCloudKit.RevocationTrustEvaluator {
  public static var revocationChecking: SwarmCloudKit.RevocationTrustEvaluator {
    get
  }
  public static func revocationChecking(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: SwarmCloudKit.RevocationTrustEvaluator.Options = .any) -> SwarmCloudKit.RevocationTrustEvaluator
}
final public class PinnedCertificatesTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SwarmCloudKit.ServerTrustEvaluating where Self == SwarmCloudKit.PinnedCertificatesTrustEvaluator {
  public static var pinnedCertificates: SwarmCloudKit.PinnedCertificatesTrustEvaluator {
    get
  }
  public static func pinnedCertificates(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> SwarmCloudKit.PinnedCertificatesTrustEvaluator
}
final public class PublicKeysTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SwarmCloudKit.ServerTrustEvaluating where Self == SwarmCloudKit.PublicKeysTrustEvaluator {
  public static var publicKeys: SwarmCloudKit.PublicKeysTrustEvaluator {
    get
  }
  public static func publicKeys(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true) -> SwarmCloudKit.PublicKeysTrustEvaluator
}
final public class CompositeTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public init(evaluators: [any SwarmCloudKit.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension SwarmCloudKit.ServerTrustEvaluating where Self == SwarmCloudKit.CompositeTrustEvaluator {
  public static func composite(evaluators: [any SwarmCloudKit.ServerTrustEvaluating]) -> SwarmCloudKit.CompositeTrustEvaluator
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = SwarmCloudKit.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : SwarmCloudKit.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Swift.Array where Element == any SwarmCloudKit.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Foundation.Bundle : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension Security.SecTrust : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (_ status: Darwin.OSStatus, _ result: Security.SecTrustResultType) -> any Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension Security.SecPolicy : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: SwarmCloudKit.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Swift.Array : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension Security.SecCertificate : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Swift.Int32 : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == Swift.Int32 {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension Security.SecTrustResultType : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
public struct OrderedDictionary<Key, Value> : Swift.RandomAccessCollection, Swift.MutableCollection where Key : Swift.Hashable {
  public typealias Element = (key: Key, value: Value)
  public typealias Index = Swift.Int
  public typealias SubSequence = SwarmCloudKit.OrderedDictionarySlice<Key, Value>
  public typealias LazyValues = Swift.LazyMapCollection<SwarmCloudKit.OrderedDictionary<Key, Value>, Value>
  public init()
  public init(minimumCapacity: Swift.Int)
  public init(unsorted: Swift.Dictionary<Key, Value>, areInIncreasingOrder: (SwarmCloudKit.OrderedDictionary<Key, Value>.Element, SwarmCloudKit.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows
  public init<S>(values: S, uniquelyKeyedBy extractKey: (Value) throws -> Key) rethrows where Value == S.Element, S : Swift.Sequence
  public init<S>(values: S, uniquelyKeyedBy keyPath: Swift.KeyPath<Value, Key>) where Value == S.Element, S : Swift.Sequence
  public init<S>(uniqueKeysWithValues keysAndValues: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value)
  public var orderedKeys: [Key] {
    get
  }
  public var orderedValues: SwarmCloudKit.OrderedDictionary<Key, Value>.LazyValues {
    get
  }
  public var unorderedDictionary: Swift.Dictionary<Key, Value> {
    get
  }
  public var indices: Swift.CountableRange<SwarmCloudKit.OrderedDictionary<Key, Value>.Index> {
    get
  }
  public var startIndex: SwarmCloudKit.OrderedDictionary<Key, Value>.Index {
    get
  }
  public var endIndex: SwarmCloudKit.OrderedDictionary<Key, Value>.Index {
    get
  }
  public func index(after i: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Index
  public func index(before i: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Index
  public func index(forKey key: Key) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Index?
  public subscript(key: Key) -> Value? {
    get
    set(newValue)
  }
  public func containsKey(_ key: Key) -> Swift.Bool
  public func value(forKey key: Key) -> Value?
  @discardableResult
  public mutating func updateValue(_ value: Value, forKey key: Key) -> Value?
  @discardableResult
  public mutating func removeValue(forKey key: Key) -> Value?
  public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false)
  public subscript(position: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element {
    get
    set(newElement)
  }
  public subscript(bounds: Swift.Range<SwarmCloudKit.OrderedDictionary<Key, Value>.Index>) -> SwarmCloudKit.OrderedDictionary<Key, Value>.SubSequence {
    get
    set(newElements)
  }
  public func elementAt(_ index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element?
  public func canInsert(key: Key) -> Swift.Bool
  public func canInsert(at index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> Swift.Bool
  public mutating func insert(_ newElement: SwarmCloudKit.OrderedDictionary<Key, Value>.Element, at index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index)
  public func canUpdate(_ newElement: SwarmCloudKit.OrderedDictionary<Key, Value>.Element, at index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> Swift.Bool
  @discardableResult
  public mutating func update(_ newElement: SwarmCloudKit.OrderedDictionary<Key, Value>.Element, at index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element
  @discardableResult
  public mutating func remove(at index: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element?
  public mutating func popFirst() -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element?
  public mutating func popLast() -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element?
  public mutating func removeFirst() -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element
  public mutating func removeLast() -> SwarmCloudKit.OrderedDictionary<Key, Value>.Element
  public mutating func sort(by areInIncreasingOrder: (SwarmCloudKit.OrderedDictionary<Key, Value>.Element, SwarmCloudKit.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows
  public func sorted(by areInIncreasingOrder: (SwarmCloudKit.OrderedDictionary<Key, Value>.Element, SwarmCloudKit.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> SwarmCloudKit.OrderedDictionary<Key, Value>
  public mutating func reverse()
  public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator
  public mutating func _shuffle<T>(in range: Swift.Range<SwarmCloudKit.OrderedDictionary<Key, Value>.Index>, using generator: inout T) where T : Swift.RandomNumberGenerator
  public mutating func partition(by belongsInSecondPartition: (SwarmCloudKit.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> SwarmCloudKit.OrderedDictionary<Key, Value>.Index
  public mutating func swapAt(_ i: SwarmCloudKit.OrderedDictionary<Key, Value>.Index, _ j: SwarmCloudKit.OrderedDictionary<Key, Value>.Index)
  public func mapValues<T>(_ transform: (Value) throws -> T) rethrows -> SwarmCloudKit.OrderedDictionary<Key, T>
  public func compactMapValues<T>(_ transform: (Value) throws -> T?) rethrows -> SwarmCloudKit.OrderedDictionary<Key, T>
  public func filter(_ isIncluded: (SwarmCloudKit.OrderedDictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> SwarmCloudKit.OrderedDictionary<Key, Value>
  public var capacity: Swift.Int {
    get
  }
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  public typealias Indices = Swift.CountableRange<SwarmCloudKit.OrderedDictionary<Key, Value>.Index>
  public typealias Iterator = Swift.IndexingIterator<SwarmCloudKit.OrderedDictionary<Key, Value>>
}
extension SwarmCloudKit.OrderedDictionary : Swift.Hashable where Value : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.OrderedDictionary : Swift.Equatable where Value : Swift.Equatable {
  public static func == (a: SwarmCloudKit.OrderedDictionary<Key, Value>, b: SwarmCloudKit.OrderedDictionary<Key, Value>) -> Swift.Bool
}
extension SwarmCloudKit.OrderedDictionary : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: SwarmCloudKit.OrderedDictionary<Key, Value>.Element...)
  public typealias ArrayLiteralElement = SwarmCloudKit.OrderedDictionary<Key, Value>.Element
}
extension SwarmCloudKit.OrderedDictionary : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Key, Value)...)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DeflateRequestCompressor : SwarmCloudKit.RequestInterceptor {
  public enum DuplicateHeaderBehavior {
    case error
    case replace
    case skip
    public static func == (a: SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior, b: SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public struct DuplicateHeaderError : Swift.Error {
  }
  public let duplicateHeaderBehavior: SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior
  public let shouldCompressBodyData: (_ bodyData: Foundation.Data) -> Swift.Bool
  public init(duplicateHeaderBehavior: SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true })
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.RequestInterceptor where Self == SwarmCloudKit.DeflateRequestCompressor {
  public static var deflateCompressor: SwarmCloudKit.DeflateRequestCompressor {
    get
  }
  public static func deflateCompressor(duplicateHeaderBehavior: SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior = .error, shouldCompressBodyData: @escaping (_ bodyData: Foundation.Data) -> Swift.Bool = { _ in true }) -> SwarmCloudKit.DeflateRequestCompressor
}
extension Foundation.JSONDecoder {
  public static func decode<T>(_ string: Swift.String, to type: T.Type) throws -> T where T : Swift.Decodable, T : Swift.Encodable
  public static func decode<T>(_ json: [Swift.String : Any], to type: T.Type) throws -> T where T : Swift.Decodable, T : Swift.Encodable
  public static func decode<T>(_ data: Foundation.Data, to type: T.Type) throws -> T where T : Swift.Decodable, T : Swift.Encodable
}
extension SwarmCloudKit.Request {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Foundation.Notification {
  public var request: SwarmCloudKit.Request? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : SwarmCloudKit.EventMonitor {
  final public func requestDidResume(_ request: SwarmCloudKit.Request)
  final public func requestDidSuspend(_ request: SwarmCloudKit.Request)
  final public func requestDidCancel(_ request: SwarmCloudKit.Request)
  final public func requestDidFinish(_ request: SwarmCloudKit.Request)
  final public func request(_ request: SwarmCloudKit.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: SwarmCloudKit.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: SwarmCloudKit.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SwarmCloudKit.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SwarmCloudKit.AFError?)
  @objc deinit
}
extension SwarmCloudKit.Storage {
  final public func transformData() -> SwarmCloudKit.Storage<Key, Foundation.Data>
  final public func transformCodable<U>(ofType: U.Type) -> SwarmCloudKit.Storage<Key, U> where U : Swift.Decodable, U : Swift.Encodable
}
public typealias HlsSegmentIdGenerator = (_ streamId: Swift.String, _ sn: Swift.Int, _ segmentUrl: Swift.String, _ range: Swift.String?) -> Swift.String
public let StrictHlsSegmentIdGenerator: (_ streamId: Swift.String, _ sn: Swift.Int, _ segmentUrl: Swift.String, _ range: Swift.String?) -> Swift.String
public let SequentialHlsSegmentIdGenerator: (_ streamId: Swift.String, _ sn: Swift.Int, _ segmentUrl: Swift.String, _ range: Swift.String?) -> Swift.String
public typealias JSONDictionary = [Swift.String : Any]
public struct JSONDictionaryWrapper : Swift.Codable {
  public let jsonDictionary: SwarmCloudKit.JSONDictionary
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case jsonDictionary
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(jsonDictionary: SwarmCloudKit.JSONDictionary)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
open class BaseDestination : Swift.Hashable, Swift.Equatable {
  open var format: Swift.String
  open var asynchronously: Swift.Bool
  open var minLevel: SwarmCloudKit.SwiftyBeaver.Level
  open var levelString: SwarmCloudKit.BaseDestination.LevelString
  open var levelColor: SwarmCloudKit.BaseDestination.LevelColor
  open var calendar: Foundation.Calendar
  public struct LevelString {
    public var verbose: Swift.String
    public var debug: Swift.String
    public var info: Swift.String
    public var warning: Swift.String
    public var error: Swift.String
  }
  public struct LevelColor {
    public var verbose: Swift.String
    public var debug: Swift.String
    public var info: Swift.String
    public var warning: Swift.String
    public var error: Swift.String
  }
  public func hash(into hasher: inout Swift.Hasher)
  open var defaultHashValue: Swift.Int {
    get
  }
  public init()
  open func send(_ level: SwarmCloudKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  public func execute(synchronously: Swift.Bool, block: @escaping () -> Swift.Void)
  public func executeSynchronously<T>(block: @escaping () throws -> T) rethrows -> T
  public func addFilter(_ filter: any SwarmCloudKit.FilterType)
  public func removeFilter(_ filter: any SwarmCloudKit.FilterType)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: SwarmCloudKit.BaseDestination, rhs: SwarmCloudKit.BaseDestination) -> Swift.Bool
public enum StunMessageType : Swift.UInt {
  case BindingRequest
  case BindingResponse
  case BindingErrorResponse
  case SharedSecretRequest
  case SharedSecretResponse
  case SharedSecretErrorResponse
  public init?(rawValue: Swift.UInt)
  public typealias RawValue = Swift.UInt
  public var rawValue: Swift.UInt {
    get
  }
}
open class Session {
  public static let `default`: SwarmCloudKit.Session
  final public let session: Foundation.URLSession
  final public let delegate: SwarmCloudKit.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: (any SwarmCloudKit.RequestInterceptor)?
  final public let serverTrustManager: SwarmCloudKit.ServerTrustManager?
  final public let redirectHandler: (any SwarmCloudKit.RedirectHandler)?
  final public let cachedResponseHandler: (any SwarmCloudKit.CachedResponseHandler)?
  final public let eventMonitor: SwarmCloudKit.CompositeEventMonitor
  final public let defaultEventMonitors: [any SwarmCloudKit.EventMonitor]
  public init(session: Foundation.URLSession, delegate: SwarmCloudKit.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, serverTrustManager: SwarmCloudKit.ServerTrustManager? = nil, redirectHandler: (any SwarmCloudKit.RedirectHandler)? = nil, cachedResponseHandler: (any SwarmCloudKit.CachedResponseHandler)? = nil, eventMonitors: [any SwarmCloudKit.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: SwarmCloudKit.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, serverTrustManager: SwarmCloudKit.ServerTrustManager? = nil, redirectHandler: (any SwarmCloudKit.RedirectHandler)? = nil, cachedResponseHandler: (any SwarmCloudKit.CachedResponseHandler)? = nil, eventMonitors: [any SwarmCloudKit.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<SwarmCloudKit.Request>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, parameters: SwarmCloudKit.Parameters? = nil, encoding: any SwarmCloudKit.ParameterEncoding = URLEncoding.default, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.DataRequest
  open func request<Parameters>(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any SwarmCloudKit.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.DataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: any SwarmCloudKit.URLRequestConvertible, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil) -> SwarmCloudKit.DataRequest
  open func streamRequest<Parameters>(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any SwarmCloudKit.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SwarmCloudKit.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, headers: SwarmCloudKit.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.DataStreamRequest
  open func streamRequest(_ convertible: any SwarmCloudKit.URLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil) -> SwarmCloudKit.DataStreamRequest
  open func download(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, parameters: SwarmCloudKit.Parameters? = nil, encoding: any SwarmCloudKit.ParameterEncoding = URLEncoding.default, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil, to destination: SwarmCloudKit.DownloadRequest.Destination? = nil) -> SwarmCloudKit.DownloadRequest
  open func download<Parameters>(_ convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .get, parameters: Parameters? = nil, encoder: any SwarmCloudKit.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil, to destination: SwarmCloudKit.DownloadRequest.Destination? = nil) -> SwarmCloudKit.DownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: any SwarmCloudKit.URLRequestConvertible, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, to destination: SwarmCloudKit.DownloadRequest.Destination? = nil) -> SwarmCloudKit.DownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, to destination: SwarmCloudKit.DownloadRequest.Destination? = nil) -> SwarmCloudKit.DownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .post, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.UploadRequest
  open func upload(_ data: Foundation.Data, with convertible: any SwarmCloudKit.URLRequestConvertible, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> SwarmCloudKit.UploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .post, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.UploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: any SwarmCloudKit.URLRequestConvertible, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> SwarmCloudKit.UploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod = .post, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.UploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: any SwarmCloudKit.URLRequestConvertible, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> SwarmCloudKit.UploadRequest
  open func upload(multipartFormData: @escaping (SwarmCloudKit.MultipartFormData) -> Swift.Void, to url: any SwarmCloudKit.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: SwarmCloudKit.HTTPMethod = .post, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.UploadRequest
  open func upload(multipartFormData: @escaping (SwarmCloudKit.MultipartFormData) -> Swift.Void, with request: any SwarmCloudKit.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> SwarmCloudKit.UploadRequest
  open func upload(multipartFormData: SwarmCloudKit.MultipartFormData, to url: any SwarmCloudKit.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, method: SwarmCloudKit.HTTPMethod = .post, headers: SwarmCloudKit.HTTPHeaders? = nil, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SwarmCloudKit.Session.RequestModifier? = nil) -> SwarmCloudKit.UploadRequest
  open func upload(multipartFormData: SwarmCloudKit.MultipartFormData, with request: any SwarmCloudKit.URLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = MultipartFormData.encodingMemoryThreshold, interceptor: (any SwarmCloudKit.RequestInterceptor)? = nil, fileManager: Foundation.FileManager = .default) -> SwarmCloudKit.UploadRequest
}
extension SwarmCloudKit.Session : SwarmCloudKit.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: SwarmCloudKit.Request)
  public func retryResult(for request: SwarmCloudKit.Request, dueTo error: SwarmCloudKit.AFError, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: SwarmCloudKit.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
public class HttpRequest {
  public var path: Swift.String
  public var queryParams: [(Swift.String, Swift.String)]
  public var method: Swift.String
  public var headers: [Swift.String : Swift.String]
  public var body: [Swift.UInt8]
  public var address: Swift.String?
  public var params: [Swift.String : Swift.String]
  public init()
  public func hasTokenForHeader(_ headerName: Swift.String, token: Swift.String) -> Swift.Bool
  public func parseUrlencodedForm() -> [(Swift.String, Swift.String)]
  public struct MultiPart {
    public let headers: [Swift.String : Swift.String]
    public let body: [Swift.UInt8]
  }
  public func parseMultiPartFormData() -> [SwarmCloudKit.HttpRequest.MultiPart]
  @objc deinit
}
open class RetryPolicy : SwarmCloudKit.RequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  open func shouldRetry(request: SwarmCloudKit.Request, dueTo error: any Swift.Error) -> Swift.Bool
  @objc deinit
}
extension SwarmCloudKit.RequestInterceptor where Self == SwarmCloudKit.RetryPolicy {
  public static var retryPolicy: SwarmCloudKit.RetryPolicy {
    get
  }
  public static func retryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes) -> SwarmCloudKit.RetryPolicy
}
open class ConnectionLostRetryPolicy : SwarmCloudKit.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  @objc deinit
}
extension SwarmCloudKit.RequestInterceptor where Self == SwarmCloudKit.ConnectionLostRetryPolicy {
  public static var connectionLostRetryPolicy: SwarmCloudKit.ConnectionLostRetryPolicy {
    get
  }
  public static func connectionLostRetryPolicy(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods) -> SwarmCloudKit.ConnectionLostRetryPolicy
}
public protocol StorageObservationRegistry {
  associatedtype S : SwarmCloudKit.StorageAware
  @discardableResult
  func addStorageObserver<O>(_ observer: O, closure: @escaping (O, Self.S, SwarmCloudKit.StorageChange<Self.S.Key>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  func removeAllStorageObservers()
}
public enum StorageChange<Key> : Swift.Equatable where Key : Swift.Hashable {
  case add(key: Key)
  case remove(key: Key)
  case removeAll
  case removeExpired
  case removeInMemory(key: Key)
}
public func == <Key>(lhs: SwarmCloudKit.StorageChange<Key>, rhs: SwarmCloudKit.StorageChange<Key>) -> Swift.Bool where Key : Swift.Hashable
@objc public protocol PlayerInteractor {
  @objc optional func onBufferedDuration() -> Foundation.TimeInterval
  @objc optional func onCurrentPosition() -> Foundation.TimeInterval
}
public func MD5(_ input: Swift.String) -> Swift.String
@_inheritsConvenienceInitializers open class HttpServer : SwarmCloudKit.HttpServerIO {
  public static let VERSION: Swift.String
  public init()
  public var DELETE: SwarmCloudKit.HttpServer.MethodRoute, PATCH: SwarmCloudKit.HttpServer.MethodRoute, HEAD: SwarmCloudKit.HttpServer.MethodRoute, POST: SwarmCloudKit.HttpServer.MethodRoute, GET: SwarmCloudKit.HttpServer.MethodRoute, PUT: SwarmCloudKit.HttpServer.MethodRoute
  public var delete: SwarmCloudKit.HttpServer.MethodRoute, patch: SwarmCloudKit.HttpServer.MethodRoute, head: SwarmCloudKit.HttpServer.MethodRoute, post: SwarmCloudKit.HttpServer.MethodRoute, get: SwarmCloudKit.HttpServer.MethodRoute, put: SwarmCloudKit.HttpServer.MethodRoute
  public subscript(path: Swift.String) -> ((SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)? {
    get
    set
  }
  public var routes: [Swift.String] {
    get
  }
  public var notFoundHandler: ((SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)?
  public var middleware: [(SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse?]
  override open func dispatch(_ request: SwarmCloudKit.HttpRequest) -> ([Swift.String : Swift.String], (SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)
  public struct MethodRoute {
    public let method: Swift.String
    public let router: SwarmCloudKit.HttpRouter
    public subscript(path: Swift.String) -> ((SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)? {
      get
      set
    }
  }
  @objc deinit
}
public struct DiskConfig {
  public let name: Swift.String
  public let expiry: SwarmCloudKit.Expiry
  public let maxSize: Swift.UInt
  public let directory: Foundation.URL?
  public let protectionType: Foundation.FileProtectionType?
  public init(name: Swift.String, expiry: SwarmCloudKit.Expiry = .never, maxSize: Swift.UInt = 0, directory: Foundation.URL? = nil, protectionType: Foundation.FileProtectionType? = nil)
}
extension Swift.Optional {
  public func unwrapOrThrow(error: any Swift.Error) throws -> Wrapped
}
public protocol FilterType : AnyObject {
  func apply(_ value: Swift.String?) -> Swift.Bool
  func getTarget() -> SwarmCloudKit.Filter.TargetType
  func isRequired() -> Swift.Bool
  func isExcluded() -> Swift.Bool
  func reachedMinLevel(_ level: SwarmCloudKit.SwiftyBeaver.Level) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class Filters {
  public static let Path: SwarmCloudKit.PathFilterFactory.Type
  public static let Function: SwarmCloudKit.FunctionFilterFactory.Type
  public static let Message: SwarmCloudKit.MessageFilterFactory.Type
  @objc deinit
}
public class Filter {
  public enum TargetType {
    case Path(SwarmCloudKit.Filter.ComparisonType)
    case Function(SwarmCloudKit.Filter.ComparisonType)
    case Message(SwarmCloudKit.Filter.ComparisonType)
  }
  public enum ComparisonType {
    case StartsWith([Swift.String], Swift.Bool)
    case Contains([Swift.String], Swift.Bool)
    case Excludes([Swift.String], Swift.Bool)
    case EndsWith([Swift.String], Swift.Bool)
    case Equals([Swift.String], Swift.Bool)
    case Custom((Swift.String) -> Swift.Bool)
  }
  public init(_ target: SwarmCloudKit.Filter.TargetType, required: Swift.Bool, minLevel: SwarmCloudKit.SwiftyBeaver.Level)
  public func getTarget() -> SwarmCloudKit.Filter.TargetType
  public func isRequired() -> Swift.Bool
  public func isExcluded() -> Swift.Bool
  public func reachedMinLevel(_ level: SwarmCloudKit.SwiftyBeaver.Level) -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers public class CompareFilter : SwarmCloudKit.Filter, SwarmCloudKit.FilterType {
  override public init(_ target: SwarmCloudKit.Filter.TargetType, required: Swift.Bool, minLevel: SwarmCloudKit.SwiftyBeaver.Level)
  public func apply(_ value: Swift.String?) -> Swift.Bool
  override public func isExcluded() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FunctionFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any SwarmCloudKit.FilterType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MessageFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any SwarmCloudKit.FilterType
  @objc deinit
}
@_hasMissingDesignatedInitializers public class PathFilterFactory {
  public static func startsWith(_ prefixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func contains(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func excludes(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func endsWith(_ suffixes: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func equals(_ strings: Swift.String..., caseSensitive: Swift.Bool = false, required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose) -> any SwarmCloudKit.FilterType
  public static func custom(required: Swift.Bool = false, minLevel: SwarmCloudKit.SwiftyBeaver.Level = .verbose, filterPredicate: @escaping (Swift.String) -> Swift.Bool) -> any SwarmCloudKit.FilterType
  @objc deinit
}
extension SwarmCloudKit.Filter.TargetType : Swift.Equatable {
}
public func == (lhs: SwarmCloudKit.Filter.TargetType, rhs: SwarmCloudKit.Filter.TargetType) -> Swift.Bool
extension Foundation.FileManager {
  public func sizeOfDirectory(at url: Foundation.URL) -> Swift.Int?
}
public func synchronized<T>(_ lock: Swift.AnyObject, _ body: () throws -> T) rethrows -> T
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: SwarmCloudKit.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SwarmCloudKit.Request, didFailToCreateURLRequestWithError error: SwarmCloudKit.AFError)
  func request(_ request: SwarmCloudKit.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: SwarmCloudKit.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SwarmCloudKit.AFError)
  func request(_ request: SwarmCloudKit.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SwarmCloudKit.Request, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: SwarmCloudKit.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: SwarmCloudKit.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SwarmCloudKit.AFError)
  func request(_ request: SwarmCloudKit.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SwarmCloudKit.AFError?)
  func requestIsRetrying(_ request: SwarmCloudKit.Request)
  func requestDidFinish(_ request: SwarmCloudKit.Request)
  func requestDidResume(_ request: SwarmCloudKit.Request)
  func request(_ request: SwarmCloudKit.Request, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: SwarmCloudKit.Request)
  func request(_ request: SwarmCloudKit.Request, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: SwarmCloudKit.Request)
  func request(_ request: SwarmCloudKit.Request, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: SwarmCloudKit.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SwarmCloudKit.Request.ValidationResult)
  func request(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Foundation.Data?, SwarmCloudKit.AFError>)
  func request<Value>(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError>)
  func request(_ request: SwarmCloudKit.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SwarmCloudKit.Request.ValidationResult)
  func request<Value>(_ request: SwarmCloudKit.DataStreamRequest, didParseStream result: Swift.Result<Value, SwarmCloudKit.AFError>)
  func request(_ request: SwarmCloudKit.UploadRequest, didCreateUploadable uploadable: SwarmCloudKit.UploadRequest.Uploadable)
  func request(_ request: SwarmCloudKit.UploadRequest, didFailToCreateUploadableWithError error: SwarmCloudKit.AFError)
  func request(_ request: SwarmCloudKit.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: SwarmCloudKit.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SwarmCloudKit.AFError>)
  func request(_ request: SwarmCloudKit.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: SwarmCloudKit.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SwarmCloudKit.Request.ValidationResult)
  func request(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Foundation.URL?, SwarmCloudKit.AFError>)
  func request<Value>(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError>)
}
extension SwarmCloudKit.EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: SwarmCloudKit.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SwarmCloudKit.Request, didFailToCreateURLRequestWithError error: SwarmCloudKit.AFError)
  public func request(_ request: SwarmCloudKit.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: SwarmCloudKit.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SwarmCloudKit.AFError)
  public func request(_ request: SwarmCloudKit.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SwarmCloudKit.Request, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: SwarmCloudKit.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: SwarmCloudKit.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SwarmCloudKit.AFError)
  public func request(_ request: SwarmCloudKit.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SwarmCloudKit.AFError?)
  public func requestIsRetrying(_ request: SwarmCloudKit.Request)
  public func requestDidFinish(_ request: SwarmCloudKit.Request)
  public func requestDidResume(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: SwarmCloudKit.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SwarmCloudKit.Request.ValidationResult)
  public func request(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Foundation.Data?, SwarmCloudKit.AFError>)
  public func request<Value>(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError>)
  public func request(_ request: SwarmCloudKit.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SwarmCloudKit.Request.ValidationResult)
  public func request<Value>(_ request: SwarmCloudKit.DataStreamRequest, didParseStream result: Swift.Result<Value, SwarmCloudKit.AFError>)
  public func request(_ request: SwarmCloudKit.UploadRequest, didCreateUploadable uploadable: SwarmCloudKit.UploadRequest.Uploadable)
  public func request(_ request: SwarmCloudKit.UploadRequest, didFailToCreateUploadableWithError error: SwarmCloudKit.AFError)
  public func request(_ request: SwarmCloudKit.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: SwarmCloudKit.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SwarmCloudKit.AFError>)
  public func request(_ request: SwarmCloudKit.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: SwarmCloudKit.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SwarmCloudKit.Request.ValidationResult)
  public func request(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Foundation.URL?, SwarmCloudKit.AFError>)
  public func request<Value>(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : SwarmCloudKit.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: SwarmCloudKit.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SwarmCloudKit.Request, didFailToCreateURLRequestWithError error: SwarmCloudKit.AFError)
  final public func request(_ request: SwarmCloudKit.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: SwarmCloudKit.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SwarmCloudKit.AFError)
  final public func request(_ request: SwarmCloudKit.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SwarmCloudKit.Request, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: SwarmCloudKit.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: SwarmCloudKit.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SwarmCloudKit.AFError)
  final public func request(_ request: SwarmCloudKit.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SwarmCloudKit.AFError?)
  final public func requestIsRetrying(_ request: SwarmCloudKit.Request)
  final public func requestDidFinish(_ request: SwarmCloudKit.Request)
  final public func requestDidResume(_ request: SwarmCloudKit.Request)
  final public func request(_ request: SwarmCloudKit.Request, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: SwarmCloudKit.Request)
  final public func request(_ request: SwarmCloudKit.Request, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: SwarmCloudKit.Request)
  final public func request(_ request: SwarmCloudKit.Request, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SwarmCloudKit.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SwarmCloudKit.Request.ValidationResult)
  final public func request(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Foundation.Data?, SwarmCloudKit.AFError>)
  final public func request<Value>(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError>)
  final public func request(_ request: SwarmCloudKit.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SwarmCloudKit.Request.ValidationResult)
  final public func request<Value>(_ request: SwarmCloudKit.DataStreamRequest, didParseStream result: Swift.Result<Value, SwarmCloudKit.AFError>)
  final public func request(_ request: SwarmCloudKit.UploadRequest, didCreateUploadable uploadable: SwarmCloudKit.UploadRequest.Uploadable)
  final public func request(_ request: SwarmCloudKit.UploadRequest, didFailToCreateUploadableWithError error: SwarmCloudKit.AFError)
  final public func request(_ request: SwarmCloudKit.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: SwarmCloudKit.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SwarmCloudKit.AFError>)
  final public func request(_ request: SwarmCloudKit.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: SwarmCloudKit.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SwarmCloudKit.Request.ValidationResult)
  final public func request(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Foundation.URL?, SwarmCloudKit.AFError>)
  final public func request<Value>(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : SwarmCloudKit.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, (any Swift.Error)?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, (any Swift.Error)?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((SwarmCloudKit.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((SwarmCloudKit.Request, SwarmCloudKit.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((SwarmCloudKit.Request, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((SwarmCloudKit.Request, Foundation.URLRequest, SwarmCloudKit.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((SwarmCloudKit.Request, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((SwarmCloudKit.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((SwarmCloudKit.Request, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((SwarmCloudKit.Request, Foundation.URLSessionTask, SwarmCloudKit.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((SwarmCloudKit.Request, Foundation.URLSessionTask, SwarmCloudKit.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((SwarmCloudKit.Request) -> Swift.Void)?
  open var requestDidFinish: ((SwarmCloudKit.Request) -> Swift.Void)?
  open var requestDidResume: ((SwarmCloudKit.Request) -> Swift.Void)?
  open var requestDidResumeTask: ((SwarmCloudKit.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((SwarmCloudKit.Request) -> Swift.Void)?
  open var requestDidSuspendTask: ((SwarmCloudKit.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((SwarmCloudKit.Request) -> Swift.Void)?
  open var requestDidCancelTask: ((SwarmCloudKit.Request, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((SwarmCloudKit.DataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, SwarmCloudKit.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((SwarmCloudKit.DataRequest, SwarmCloudKit.DataResponse<Foundation.Data?, SwarmCloudKit.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((SwarmCloudKit.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, SwarmCloudKit.Request.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((SwarmCloudKit.UploadRequest, SwarmCloudKit.UploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((SwarmCloudKit.UploadRequest, SwarmCloudKit.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((SwarmCloudKit.UploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((SwarmCloudKit.DownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, SwarmCloudKit.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((SwarmCloudKit.DownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((SwarmCloudKit.DownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, SwarmCloudKit.Request.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((SwarmCloudKit.DownloadRequest, SwarmCloudKit.DownloadResponse<Foundation.URL?, SwarmCloudKit.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: SwarmCloudKit.Request, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SwarmCloudKit.Request, didFailToCreateURLRequestWithError error: SwarmCloudKit.AFError)
  open func request(_ request: SwarmCloudKit.Request, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: SwarmCloudKit.Request, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SwarmCloudKit.AFError)
  open func request(_ request: SwarmCloudKit.Request, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SwarmCloudKit.Request, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: SwarmCloudKit.Request, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: SwarmCloudKit.Request, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SwarmCloudKit.AFError)
  open func request(_ request: SwarmCloudKit.Request, didCompleteTask task: Foundation.URLSessionTask, with error: SwarmCloudKit.AFError?)
  open func requestIsRetrying(_ request: SwarmCloudKit.Request)
  open func requestDidFinish(_ request: SwarmCloudKit.Request)
  open func requestDidResume(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: SwarmCloudKit.Request)
  public func request(_ request: SwarmCloudKit.Request, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: SwarmCloudKit.DataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SwarmCloudKit.Request.ValidationResult)
  open func request(_ request: SwarmCloudKit.DataRequest, didParseResponse response: SwarmCloudKit.DataResponse<Foundation.Data?, SwarmCloudKit.AFError>)
  public func request(_ request: SwarmCloudKit.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SwarmCloudKit.Request.ValidationResult)
  open func request(_ request: SwarmCloudKit.UploadRequest, didCreateUploadable uploadable: SwarmCloudKit.UploadRequest.Uploadable)
  open func request(_ request: SwarmCloudKit.UploadRequest, didFailToCreateUploadableWithError error: SwarmCloudKit.AFError)
  open func request(_ request: SwarmCloudKit.UploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: SwarmCloudKit.DownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SwarmCloudKit.AFError>)
  open func request(_ request: SwarmCloudKit.DownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: SwarmCloudKit.DownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SwarmCloudKit.Request.ValidationResult)
  open func request(_ request: SwarmCloudKit.DownloadRequest, didParseResponse response: SwarmCloudKit.DownloadResponse<Foundation.URL?, SwarmCloudKit.AFError>)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Request {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: SwarmCloudKit.Request.State, b: SwarmCloudKit.Request.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: (any SwarmCloudKit.EventMonitor)?
  final public let interceptor: (any SwarmCloudKit.RequestInterceptor)?
  weak public var delegate: (any SwarmCloudKit.RequestDelegate)? {
    get
  }
  public var state: SwarmCloudKit.Request.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: (any SwarmCloudKit.RedirectHandler)? {
    get
  }
  public var cachedResponseHandler: (any SwarmCloudKit.CachedResponseHandler)? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: SwarmCloudKit.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SwarmCloudKit.Request.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SwarmCloudKit.Request.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: any SwarmCloudKit.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: any SwarmCloudKit.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension SwarmCloudKit.Request : Swift.Equatable {
  public static func == (lhs: SwarmCloudKit.Request, rhs: SwarmCloudKit.Request) -> Swift.Bool
}
extension SwarmCloudKit.Request : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.Request : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SwarmCloudKit.Request {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: SwarmCloudKit.Request)
  func retryResult(for request: SwarmCloudKit.Request, dueTo error: SwarmCloudKit.AFError, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  func retryRequest(_ request: SwarmCloudKit.Request, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class DataRequest : SwarmCloudKit.Request {
  final public let convertible: any SwarmCloudKit.URLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping SwarmCloudKit.DataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : SwarmCloudKit.Request {
  public typealias Handler<Success, Failure> = (SwarmCloudKit.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: SwarmCloudKit.DataStreamRequest.Event<Success, Failure>
    public let token: SwarmCloudKit.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(SwarmCloudKit.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: SwarmCloudKit.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: any SwarmCloudKit.URLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping SwarmCloudKit.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension SwarmCloudKit.DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: SwarmCloudKit.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class DownloadRequest : SwarmCloudKit.Request {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: SwarmCloudKit.DownloadRequest.Options
    public static let removePreviousFile: SwarmCloudKit.DownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = SwarmCloudKit.DownloadRequest.Options
    public typealias Element = SwarmCloudKit.DownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (_ temporaryURL: Foundation.URL, _ response: Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: SwarmCloudKit.DownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: SwarmCloudKit.DownloadRequest.Options = []) -> SwarmCloudKit.DownloadRequest.Destination
  public enum Downloadable {
    case request(any SwarmCloudKit.URLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: SwarmCloudKit.DownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (_ data: Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping SwarmCloudKit.DownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class UploadRequest : SwarmCloudKit.DataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: any SwarmCloudKit.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: SwarmCloudKit.UploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> SwarmCloudKit.UploadRequest.Uploadable
}
extension SwarmCloudKit.UploadRequest.Uploadable : SwarmCloudKit.UploadableConvertible {
  public func createUploadable() throws -> SwarmCloudKit.UploadRequest.Uploadable
}
public protocol UploadConvertible : SwarmCloudKit.URLRequestConvertible, SwarmCloudKit.UploadableConvertible {
}
@_hasMissingDesignatedInitializers open class NetworkInterfaces {
  public struct NetworkInterfaceInfo {
    public let name: Swift.String
    public let ip: Swift.String
    public let netmask: Swift.String
  }
  public static func enumerate() -> [SwarmCloudKit.NetworkInterfaces.NetworkInterfaceInfo]
  @objc deinit
}
public protocol StorageAware {
  associatedtype Key : Swift.Hashable
  associatedtype Value
  var allKeys: [Self.Key] { get }
  var allObjects: [Self.Value] { get }
  func object(forKey key: Self.Key) throws -> Self.Value
  func entry(forKey key: Self.Key) throws -> SwarmCloudKit.Entry<Self.Value>
  func removeObject(forKey key: Self.Key) throws
  func setObject(_ object: Self.Value, forKey key: Self.Key, expiry: SwarmCloudKit.Expiry?) throws
  @available(*, deprecated, renamed: "objectExists(forKey:)")
  func existsObject(forKey key: Self.Key) throws -> Swift.Bool
  func objectExists(forKey key: Self.Key) -> Swift.Bool
  func removeAll() throws
  func removeExpiredObjects() throws
  func isExpiredObject(forKey key: Self.Key) throws -> Swift.Bool
  func removeInMemoryObject(forKey key: Self.Key) throws
}
extension SwarmCloudKit.StorageAware {
  public func object(forKey key: Self.Key) throws -> Self.Value
  public func existsObject(forKey key: Self.Key) throws -> Swift.Bool
  public func objectExists(forKey key: Self.Key) -> Swift.Bool
  public func isExpiredObject(forKey key: Self.Key) throws -> Swift.Bool
}
final public class DiskStorage<Key, Value> where Key : Swift.Hashable {
  final public let fileManager: Foundation.FileManager
  final public let path: Swift.String
  convenience public init(config: SwarmCloudKit.DiskConfig, fileManager: Foundation.FileManager = FileManager.default, transformer: SwarmCloudKit.Transformer<Value>) throws
  required public init(config: SwarmCloudKit.DiskConfig, fileManager: Foundation.FileManager = FileManager.default, path: Swift.String, transformer: SwarmCloudKit.Transformer<Value>)
  @objc deinit
}
extension SwarmCloudKit.DiskStorage : SwarmCloudKit.StorageAware {
  final public var allKeys: [Key] {
    get
  }
  final public var allObjects: [Value] {
    get
  }
  final public func entry(forKey key: Key) throws -> SwarmCloudKit.Entry<Value>
  final public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil) throws
  final public func removeObject(forKey key: Key) throws
  final public func removeAll() throws
  final public func removeExpiredObjects() throws
  final public func removeInMemoryObject(forKey key: Key) throws
}
extension SwarmCloudKit.DiskStorage {
  final public func transform<U>(transformer: SwarmCloudKit.Transformer<U>) -> SwarmCloudKit.DiskStorage<Key, U>
}
extension SwarmCloudKit.DiskStorage {
  final public var totalSize: Swift.Int? {
    get
  }
}
public typealias JSONArray = [SwarmCloudKit.JSONDictionary]
public struct JSONArrayWrapper : Swift.Codable {
  public let jsonArray: SwarmCloudKit.JSONArray
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case jsonArray
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(jsonArray: SwarmCloudKit.JSONArray)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum SwiftyJSONError : Swift.Int, Swift.Error {
  case unsupportedType
  case indexOutOfBounds
  case elementTooDeep
  case wrongType
  case notExist
  case invalidJSON
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.SwiftyJSONError : Foundation.CustomNSError {
  public static var errorDomain: Swift.String {
    get
  }
  public var errorCode: Swift.Int {
    get
  }
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
public enum Type : Swift.Int {
  case number
  case string
  case bool
  case array
  case dictionary
  case null
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct JSON {
  public init(data: Foundation.Data, options opt: Foundation.JSONSerialization.ReadingOptions = []) throws
  public init(_ object: Any)
  public init(parseJSON jsonString: Swift.String)
  public mutating func merge(with other: SwarmCloudKit.JSON) throws
  public func merged(with other: SwarmCloudKit.JSON) throws -> SwarmCloudKit.JSON
  public var type: SwarmCloudKit.`Type` {
    get
  }
  public var error: SwarmCloudKit.SwiftyJSONError? {
    get
  }
  public var object: Any {
    get
    set
  }
  @available(*, unavailable, renamed: "null")
  public static var nullJSON: SwarmCloudKit.JSON {
    get
  }
  public static var null: SwarmCloudKit.JSON {
    get
  }
}
public enum Index<T> : Swift.Comparable {
  case array(Swift.Int)
  case dictionary(Swift.DictionaryIndex<Swift.String, T>)
  case null
  public static func == (lhs: SwarmCloudKit.Index<T>, rhs: SwarmCloudKit.Index<T>) -> Swift.Bool
  public static func < (lhs: SwarmCloudKit.Index<T>, rhs: SwarmCloudKit.Index<T>) -> Swift.Bool
}
public typealias JSONIndex = SwarmCloudKit.Index<SwarmCloudKit.JSON>
public typealias JSONRawIndex = SwarmCloudKit.Index<Any>
extension SwarmCloudKit.JSON : Swift.Collection {
  public typealias Index = SwarmCloudKit.JSONRawIndex
  public var startIndex: SwarmCloudKit.JSON.Index {
    get
  }
  public var endIndex: SwarmCloudKit.JSON.Index {
    get
  }
  public func index(after i: SwarmCloudKit.JSON.Index) -> SwarmCloudKit.JSON.Index
  public subscript(position: SwarmCloudKit.JSON.Index) -> (Swift.String, SwarmCloudKit.JSON) {
    get
  }
  public typealias Element = (Swift.String, SwarmCloudKit.JSON)
  public typealias Indices = Swift.DefaultIndices<SwarmCloudKit.JSON>
  public typealias Iterator = Swift.IndexingIterator<SwarmCloudKit.JSON>
  public typealias SubSequence = Swift.Slice<SwarmCloudKit.JSON>
}
public enum JSONKey {
  case index(Swift.Int)
  case key(Swift.String)
}
public protocol JSONSubscriptType {
  var jsonKey: SwarmCloudKit.JSONKey { get }
}
extension Swift.Int : SwarmCloudKit.JSONSubscriptType {
  public var jsonKey: SwarmCloudKit.JSONKey {
    get
  }
}
extension Swift.String : SwarmCloudKit.JSONSubscriptType {
  public var jsonKey: SwarmCloudKit.JSONKey {
    get
  }
}
extension SwarmCloudKit.JSON {
  public subscript(path: [any SwarmCloudKit.JSONSubscriptType]) -> SwarmCloudKit.JSON {
    get
    set
  }
  public subscript(path: any SwarmCloudKit.JSONSubscriptType...) -> SwarmCloudKit.JSON {
    get
    set
  }
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(extendedGraphemeClusterLiteral value: Swift.StringLiteralType)
  public init(unicodeScalarLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.IntegerLiteralType)
  public typealias IntegerLiteralType = Swift.IntegerLiteralType
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.BooleanLiteralType)
  public typealias BooleanLiteralType = Swift.BooleanLiteralType
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.FloatLiteralType)
  public typealias FloatLiteralType = Swift.FloatLiteralType
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Any)...)
  public typealias Key = Swift.String
  public typealias Value = Any
}
extension SwarmCloudKit.JSON : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Any...)
  public typealias ArrayLiteralElement = Any
}
extension SwarmCloudKit.JSON : Swift.RawRepresentable {
  public init?(rawValue: Any)
  public var rawValue: Any {
    get
  }
  public func rawData(options opt: Foundation.JSONSerialization.WritingOptions = JSONSerialization.WritingOptions(rawValue: 0)) throws -> Foundation.Data
  public func rawString(_ encoding: Swift.String.Encoding = .utf8, options opt: Foundation.JSONSerialization.WritingOptions = .prettyPrinted) -> Swift.String?
  public func rawString(_ options: [SwarmCloudKit.writingOptionsKeys : Any]) -> Swift.String?
  public typealias RawValue = Any
}
extension SwarmCloudKit.JSON : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SwarmCloudKit.JSON {
  public var array: [SwarmCloudKit.JSON]? {
    get
  }
  public var arrayValue: [SwarmCloudKit.JSON] {
    get
  }
  public var arrayObject: [Any]? {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var dictionary: [Swift.String : SwarmCloudKit.JSON]? {
    get
  }
  public var dictionaryValue: [Swift.String : SwarmCloudKit.JSON] {
    get
  }
  public var dictionaryObject: [Swift.String : Any]? {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var bool: Swift.Bool? {
    get
    set
  }
  public var boolValue: Swift.Bool {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var string: Swift.String? {
    get
    set
  }
  public var stringValue: Swift.String {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var number: Foundation.NSNumber? {
    get
    set
  }
  public var numberValue: Foundation.NSNumber {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var null: Foundation.NSNull? {
    get
    set
  }
  public func exists() -> Swift.Bool
}
extension SwarmCloudKit.JSON {
  public var url: Foundation.URL? {
    get
    set
  }
}
extension SwarmCloudKit.JSON {
  public var double: Swift.Double? {
    get
    set
  }
  public var doubleValue: Swift.Double {
    get
    set
  }
  public var float: Swift.Float? {
    get
    set
  }
  public var floatValue: Swift.Float {
    get
    set
  }
  public var int: Swift.Int? {
    get
    set
  }
  public var intValue: Swift.Int {
    get
    set
  }
  public var uInt: Swift.UInt? {
    get
    set
  }
  public var uIntValue: Swift.UInt {
    get
    set
  }
  public var int8: Swift.Int8? {
    get
    set
  }
  public var int8Value: Swift.Int8 {
    get
    set
  }
  public var uInt8: Swift.UInt8? {
    get
    set
  }
  public var uInt8Value: Swift.UInt8 {
    get
    set
  }
  public var int16: Swift.Int16? {
    get
    set
  }
  public var int16Value: Swift.Int16 {
    get
    set
  }
  public var uInt16: Swift.UInt16? {
    get
    set
  }
  public var uInt16Value: Swift.UInt16 {
    get
    set
  }
  public var int32: Swift.Int32? {
    get
    set
  }
  public var int32Value: Swift.Int32 {
    get
    set
  }
  public var uInt32: Swift.UInt32? {
    get
    set
  }
  public var uInt32Value: Swift.UInt32 {
    get
    set
  }
  public var int64: Swift.Int64? {
    get
    set
  }
  public var int64Value: Swift.Int64 {
    get
    set
  }
  public var uInt64: Swift.UInt64? {
    get
    set
  }
  public var uInt64Value: Swift.UInt64 {
    get
    set
  }
}
extension SwarmCloudKit.JSON : Swift.Comparable {
}
public func == (lhs: SwarmCloudKit.JSON, rhs: SwarmCloudKit.JSON) -> Swift.Bool
public func <= (lhs: SwarmCloudKit.JSON, rhs: SwarmCloudKit.JSON) -> Swift.Bool
public func >= (lhs: SwarmCloudKit.JSON, rhs: SwarmCloudKit.JSON) -> Swift.Bool
public func > (lhs: SwarmCloudKit.JSON, rhs: SwarmCloudKit.JSON) -> Swift.Bool
public func < (lhs: SwarmCloudKit.JSON, rhs: SwarmCloudKit.JSON) -> Swift.Bool
public enum writingOptionsKeys {
  case jsonSerialization
  case castNilToNSNull
  case maxObjextDepth
  case encoding
  public static func == (a: SwarmCloudKit.writingOptionsKeys, b: SwarmCloudKit.writingOptionsKeys) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.JSON : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
final public class Storage<Key, Value> where Key : Swift.Hashable {
  convenience public init(diskConfig: SwarmCloudKit.DiskConfig?, memoryConfig: SwarmCloudKit.MemoryConfig, transformer: SwarmCloudKit.Transformer<Value>)
  public init(hybridStorage: SwarmCloudKit.HybridStorage<Key, Value>)
  final public var async: SwarmCloudKit.AsyncStorage<Key, Value> {
    get
    set
  }
  @objc deinit
}
extension SwarmCloudKit.Storage : SwarmCloudKit.StorageAware {
  final public func removeInMemoryObject(forKey key: Key) throws
  final public var allKeys: [Key] {
    get
  }
  final public var allObjects: [Value] {
    get
  }
  final public func entry(forKey key: Key) throws -> SwarmCloudKit.Entry<Value>
  final public func removeObject(forKey key: Key) throws
  final public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil) throws
  final public func removeAll() throws
  final public func removeExpiredObjects() throws
}
extension SwarmCloudKit.Storage {
  final public func transform<U>(transformer: SwarmCloudKit.Transformer<U>) -> SwarmCloudKit.Storage<Key, U>
}
extension SwarmCloudKit.Storage : SwarmCloudKit.StorageObservationRegistry {
  @discardableResult
  final public func addStorageObserver<O>(_ observer: O, closure: @escaping (O, SwarmCloudKit.Storage<Key, Value>, SwarmCloudKit.StorageChange<Key>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  final public func removeAllStorageObservers()
  public typealias S = SwarmCloudKit.Storage<Key, Value>
}
extension SwarmCloudKit.Storage : SwarmCloudKit.KeyObservationRegistry {
  @discardableResult
  final public func addObserver<O>(_ observer: O, forKey key: Key, closure: @escaping (O, SwarmCloudKit.Storage<Key, Value>, SwarmCloudKit.KeyChange<Value>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  final public func removeObserver(forKey key: Key)
  final public func removeAllKeyObservers()
}
extension SwarmCloudKit.Storage {
  final public var totalDiskStorageSize: Swift.Int? {
    get
  }
}
@objc public class SignalConfig : ObjectiveC.NSObject {
  final public let mainAddr: Swift.String?
  final public let backupAddr: Swift.String?
  @objc public init(mainAddr: Swift.String? = nil, backupAddr: Swift.String? = nil)
  @objc deinit
}
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: SwarmCloudKit.ResponseCacher
  public static let doNotCache: SwarmCloudKit.ResponseCacher
  public let behavior: SwarmCloudKit.ResponseCacher.Behavior
  public init(behavior: SwarmCloudKit.ResponseCacher.Behavior)
}
extension SwarmCloudKit.ResponseCacher : SwarmCloudKit.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SwarmCloudKit.CachedResponseHandler where Self == SwarmCloudKit.ResponseCacher {
  public static var cache: SwarmCloudKit.ResponseCacher {
    get
  }
  public static var doNotCache: SwarmCloudKit.ResponseCacher {
    get
  }
  public static func modify(using closure: @escaping ((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)) -> SwarmCloudKit.ResponseCacher
}
open class StringBufferedReader : SwarmCloudKit.BufferedReader {
  public init(string: Swift.String)
  open func close()
  open func readLine() -> Swift.String?
  open func reset()
  @objc deinit
}
extension Swift.String : SwarmCloudKit.ParameterEncoding {
  public func encode(_ urlRequest: any SwarmCloudKit.URLRequestConvertible, with parameters: SwarmCloudKit.Parameters?) throws -> Foundation.URLRequest
}
public protocol KeyObservationRegistry {
  associatedtype S : SwarmCloudKit.StorageAware
  @discardableResult
  func addObserver<O>(_ observer: O, forKey key: Self.S.Key, closure: @escaping (O, Self.S, SwarmCloudKit.KeyChange<Self.S.Value>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  func removeObserver(forKey key: Self.S.Key)
  func removeAllKeyObservers()
}
public enum KeyChange<T> {
  case edit(before: T?, after: T)
  case remove
}
extension SwarmCloudKit.KeyChange : Swift.Equatable where T : Swift.Equatable {
  public static func == (lhs: SwarmCloudKit.KeyChange<T>, rhs: SwarmCloudKit.KeyChange<T>) -> Swift.Bool
}
open class MultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: SwarmCloudKit.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : SwarmCloudKit.DataResponseSerializerProtocol, SwarmCloudKit.DownloadResponseSerializerProtocol {
  var dataPreprocessor: any SwarmCloudKit.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : SwarmCloudKit.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : SwarmCloudKit.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension SwarmCloudKit.DataPreprocessor where Self == SwarmCloudKit.PassthroughPreprocessor {
  public static var passthrough: SwarmCloudKit.PassthroughPreprocessor {
    get
  }
}
extension SwarmCloudKit.DataPreprocessor where Self == SwarmCloudKit.GoogleXSSIPreprocessor {
  public static var googleXSSI: SwarmCloudKit.GoogleXSSIPreprocessor {
    get
  }
}
extension SwarmCloudKit.ResponseSerializer {
  public static var defaultDataPreprocessor: any SwarmCloudKit.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: any SwarmCloudKit.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension SwarmCloudKit.DownloadResponseSerializerProtocol where Self : SwarmCloudKit.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Self.SerializedObject
}
extension SwarmCloudKit.DataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SwarmCloudKit.DataResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SwarmCloudKit.ResponseSerializer
}
extension SwarmCloudKit.DownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SwarmCloudKit.DownloadResponseSerializerProtocol
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SwarmCloudKit.ResponseSerializer
}
public struct URLResponseSerializer : SwarmCloudKit.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: (any Swift.Error)?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension SwarmCloudKit.DownloadResponseSerializerProtocol where Self == SwarmCloudKit.URLResponseSerializer {
  public static var url: SwarmCloudKit.URLResponseSerializer {
    get
  }
}
extension SwarmCloudKit.DownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : SwarmCloudKit.ResponseSerializer {
  final public let dataPreprocessor: any SwarmCloudKit.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  public init(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension SwarmCloudKit.ResponseSerializer where Self == SwarmCloudKit.DataResponseSerializer {
  public static var data: SwarmCloudKit.DataResponseSerializer {
    get
  }
  public static func data(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DataResponseSerializer
}
extension SwarmCloudKit.DataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension SwarmCloudKit.DownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : SwarmCloudKit.ResponseSerializer {
  final public let dataPreprocessor: any SwarmCloudKit.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  public init(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension SwarmCloudKit.ResponseSerializer where Self == SwarmCloudKit.StringResponseSerializer {
  public static var string: SwarmCloudKit.StringResponseSerializer {
    get
  }
  public static func string(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.StringResponseSerializer
}
extension SwarmCloudKit.DataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension SwarmCloudKit.DownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
@available(*, deprecated, message: "JSONResponseSerializer deprecated and will be removed in Alamofire 6. Use DecodableResponseSerializer instead.")
final public class JSONResponseSerializer : SwarmCloudKit.ResponseSerializer {
  final public let dataPreprocessor: any SwarmCloudKit.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension SwarmCloudKit.DataRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension SwarmCloudKit.DownloadRequest {
  @available(*, deprecated, message: "responseJSON deprecated and will be removed in Alamofire 6. Use responseDecodable instead.")
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: SwarmCloudKit.Empty
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension SwarmCloudKit.Empty : SwarmCloudKit.EmptyResponse {
  public static func emptyValue() -> SwarmCloudKit.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension Foundation.JSONDecoder : SwarmCloudKit.DataDecoder {
}
extension Foundation.PropertyListDecoder : SwarmCloudKit.DataDecoder {
}
final public class DecodableResponseSerializer<T> : SwarmCloudKit.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: any SwarmCloudKit.DataPreprocessor
  final public let decoder: any SwarmCloudKit.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod>
  public init(dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: (any Swift.Error)?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension SwarmCloudKit.ResponseSerializer {
  public static func decodable<T>(of type: T.Type, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SwarmCloudKit.DecodableResponseSerializer<T> where Self == SwarmCloudKit.DecodableResponseSerializer<T>, T : Swift.Decodable
}
extension SwarmCloudKit.DataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension SwarmCloudKit.DownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SwarmCloudKit.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : SwarmCloudKit.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: any SwarmCloudKit.DataDecoder
  public let dataPreprocessor: any SwarmCloudKit.DataPreprocessor
  public init(decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), dataPreprocessor: any SwarmCloudKit.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : SwarmCloudKit.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : SwarmCloudKit.DataStreamSerializer {
  public init()
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension SwarmCloudKit.DataStreamSerializer {
  public static func decodable<T>(of type: T.Type, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), dataPreprocessor: any SwarmCloudKit.DataPreprocessor = PassthroughPreprocessor()) -> Self where Self == SwarmCloudKit.DecodableStreamSerializer<T>, T : Swift.Decodable
}
extension SwarmCloudKit.DataStreamSerializer where Self == SwarmCloudKit.PassthroughStreamSerializer {
  public static var passthrough: SwarmCloudKit.PassthroughStreamSerializer {
    get
  }
}
extension SwarmCloudKit.DataStreamSerializer where Self == SwarmCloudKit.StringStreamSerializer {
  public static var string: SwarmCloudKit.StringStreamSerializer {
    get
  }
}
extension SwarmCloudKit.DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SwarmCloudKit.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping SwarmCloudKit.DataStreamRequest.Handler<Serializer.SerializedObject, SwarmCloudKit.AFError>) -> Self where Serializer : SwarmCloudKit.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SwarmCloudKit.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), preprocessor: any SwarmCloudKit.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping SwarmCloudKit.DataStreamRequest.Handler<T, SwarmCloudKit.AFError>) -> Self where T : Swift.Decodable
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : SwarmCloudKit.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Self.Credential, any Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: any Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: SwarmCloudKit.AuthenticationError, b: SwarmCloudKit.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : SwarmCloudKit.RequestInterceptor where AuthenticatorType : SwarmCloudKit.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: SwarmCloudKit.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: SwarmCloudKit.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: SwarmCloudKit.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  @objc deinit
}
public typealias Async = SwarmCloudKit.AsyncBlock<Swift.Void, Swift.Void>
public struct AsyncBlock<In, Out> {
  public var output: Out? {
    get
  }
  @discardableResult
  public static func main<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func userInteractive<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func userInitiated<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func utility<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func background<O>(after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public static func custom<O>(queue: Dispatch.DispatchQueue, after seconds: Swift.Double? = nil, _ block: @escaping () -> O) -> SwarmCloudKit.AsyncBlock<Swift.Void, O>
  @discardableResult
  public func main<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  @discardableResult
  public func userInteractive<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  @discardableResult
  public func userInitiated<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  @discardableResult
  public func utility<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  @discardableResult
  public func background<O>(after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  @discardableResult
  public func custom<O>(queue: Dispatch.DispatchQueue, after seconds: Swift.Double? = nil, _ chainingBlock: @escaping (Out) -> O) -> SwarmCloudKit.AsyncBlock<Out, O>
  public func cancel()
  @discardableResult
  public func wait(seconds: Swift.Double? = nil) -> Dispatch.DispatchTimeoutResult
}
public struct Apply {
  public static func userInteractive(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func userInitiated(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func utility(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func background(_ iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
  public static func custom(queue: Dispatch.DispatchQueue, iterations: Swift.Int, block: @escaping (Swift.Int) -> ())
}
public struct AsyncGroup {
  public init()
  public func enter()
  public func leave()
  public func main(_ block: @escaping @convention(block) () -> Swift.Void)
  public func userInteractive(_ block: @escaping @convention(block) () -> Swift.Void)
  public func userInitiated(_ block: @escaping @convention(block) () -> Swift.Void)
  public func utility(_ block: @escaping @convention(block) () -> Swift.Void)
  public func background(_ block: @escaping @convention(block) () -> Swift.Void)
  public func custom(queue: Dispatch.DispatchQueue, block: @escaping @convention(block) () -> Swift.Void)
  @discardableResult
  public func wait(seconds: Swift.Double? = nil) -> Dispatch.DispatchTimeoutResult
}
extension Darwin.qos_class_t {
  public var description: Swift.String {
    get
  }
}
extension Dispatch.DispatchQoS.QoSClass {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: SwarmCloudKit.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping SwarmCloudKit.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus, b: SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
@objc public enum P2pProtocolVersion : Swift.Int {
  case V8 = 8
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class SwiftyBeaver {
  public static let version: Swift.String
  public static let build: Swift.Int
  public enum Level : Swift.Int {
    case verbose
    case debug
    case info
    case warning
    case error
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public static var destinations: Swift.Set<SwarmCloudKit.BaseDestination> {
    get
  }
  @discardableResult
  open class func addDestination(_ destination: SwarmCloudKit.BaseDestination) -> Swift.Bool
  @discardableResult
  open class func removeDestination(_ destination: SwarmCloudKit.BaseDestination) -> Swift.Bool
  open class func removeAllDestinations()
  open class func countDestinations() -> Swift.Int
  open class func threadName() -> Swift.String
  open class func verbose(_ message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func debug(_ message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func info(_ message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func warning(_ message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func error(_ message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  open class func custom(level: SwarmCloudKit.SwiftyBeaver.Level, message: @autoclosure () -> Any, file: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, context: Any? = nil)
  public class func flush(secondTimeout: Swift.Int64) -> Swift.Bool
  @objc deinit
}
public struct MemoryConfig {
  public let expiry: SwarmCloudKit.Expiry
  public let countLimit: Swift.UInt
  public let totalCostLimit: Swift.UInt
  public init(expiry: SwarmCloudKit.Expiry = .never, countLimit: Swift.UInt = 0, totalCostLimit: Swift.UInt = 0)
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc deinit
}
extension SwarmCloudKit.SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: (any Swift.Error)?)
}
extension SwarmCloudKit.SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension SwarmCloudKit.SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SwarmCloudKit.SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
public class HttpParser {
  public init()
  public func readHttpRequest(_ socket: SwarmCloudKit.Socket) throws -> SwarmCloudKit.HttpRequest
  @objc deinit
}
public struct RequestAdapterState {
  public let requestID: Foundation.UUID
  public let session: SwarmCloudKit.Session
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  func adapt(_ urlRequest: Foundation.URLRequest, using state: SwarmCloudKit.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
extension SwarmCloudKit.RequestAdapter {
  public func adapt(_ urlRequest: Foundation.URLRequest, using state: SwarmCloudKit.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(any Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
}
public protocol RequestInterceptor : SwarmCloudKit.RequestAdapter, SwarmCloudKit.RequestRetrier {
}
extension SwarmCloudKit.RequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  public func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, SwarmCloudKit.Session, _ completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (SwarmCloudKit.Request, SwarmCloudKit.Session, any Swift.Error, _ completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : SwarmCloudKit.RequestInterceptor {
  public init(_ adaptHandler: @escaping SwarmCloudKit.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: SwarmCloudKit.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  @objc deinit
}
extension SwarmCloudKit.RequestAdapter where Self == SwarmCloudKit.Adapter {
  public static func adapter(using closure: @escaping SwarmCloudKit.AdaptHandler) -> SwarmCloudKit.Adapter
}
open class Retrier : SwarmCloudKit.RequestInterceptor {
  public init(_ retryHandler: @escaping SwarmCloudKit.RetryHandler)
  open func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  @objc deinit
}
extension SwarmCloudKit.RequestRetrier where Self == SwarmCloudKit.Retrier {
  public static func retrier(using closure: @escaping SwarmCloudKit.RetryHandler) -> SwarmCloudKit.Retrier
}
open class Interceptor : SwarmCloudKit.RequestInterceptor {
  final public let adapters: [any SwarmCloudKit.RequestAdapter]
  final public let retriers: [any SwarmCloudKit.RequestRetrier]
  public init(adaptHandler: @escaping SwarmCloudKit.AdaptHandler, retryHandler: @escaping SwarmCloudKit.RetryHandler)
  public init(adapter: any SwarmCloudKit.RequestAdapter, retrier: any SwarmCloudKit.RequestRetrier)
  public init(adapters: [any SwarmCloudKit.RequestAdapter] = [], retriers: [any SwarmCloudKit.RequestRetrier] = [], interceptors: [any SwarmCloudKit.RequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SwarmCloudKit.Session, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func adapt(_ urlRequest: Foundation.URLRequest, using state: SwarmCloudKit.RequestAdapterState, completion: @escaping (Swift.Result<Foundation.URLRequest, any Swift.Error>) -> Swift.Void)
  open func retry(_ request: SwarmCloudKit.Request, for session: SwarmCloudKit.Session, dueTo error: any Swift.Error, completion: @escaping (SwarmCloudKit.RetryResult) -> Swift.Void)
  @objc deinit
}
extension SwarmCloudKit.RequestInterceptor where Self == SwarmCloudKit.Interceptor {
  public static func interceptor(adapter: @escaping SwarmCloudKit.AdaptHandler, retrier: @escaping SwarmCloudKit.RetryHandler) -> SwarmCloudKit.Interceptor
  public static func interceptor(adapter: any SwarmCloudKit.RequestAdapter, retrier: any SwarmCloudKit.RequestRetrier) -> SwarmCloudKit.Interceptor
  public static func interceptor(adapters: [any SwarmCloudKit.RequestAdapter] = [], retriers: [any SwarmCloudKit.RequestRetrier] = [], interceptors: [any SwarmCloudKit.RequestInterceptor] = []) -> SwarmCloudKit.Interceptor
}
open class HttpRouter {
  public init()
  public func routes() -> [Swift.String]
  public func register(_ method: Swift.String?, path: Swift.String, handler: ((SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)?)
  public func route(_ method: Swift.String?, path: Swift.String) -> ([Swift.String : Swift.String], (SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)?
  @objc deinit
}
public class MemoryStorage<Key, Value> : SwarmCloudKit.StorageAware where Key : Swift.Hashable {
  public init(config: SwarmCloudKit.MemoryConfig)
  @objc deinit
}
extension SwarmCloudKit.MemoryStorage {
  public var allKeys: [Key] {
    get
  }
  public var allObjects: [Value] {
    get
  }
  public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil)
  public func removeAll()
  public func trimToSize(_ size: Swift.Int)
  public func removeExpiredObjects()
  public func removeObjectIfExpired(forKey key: Key)
  public func removeObject(forKey key: Key)
  public func removeInMemoryObject(forKey key: Key) throws
  public func entry(forKey key: Key) throws -> SwarmCloudKit.Entry<Value>
}
extension SwarmCloudKit.MemoryStorage {
  public func transform<U>() -> SwarmCloudKit.MemoryStorage<Key, U>
}
public enum SocketError : Swift.Error {
  case socketCreationFailed(Swift.String)
  case socketSettingReUseAddrFailed(Swift.String)
  case bindFailed(Swift.String)
  case listenFailed(Swift.String)
  case writeFailed(Swift.String)
  case getPeerNameFailed(Swift.String)
  case convertingPeerNameFailed
  case getNameInfoFailed(Swift.String)
  case acceptFailed(Swift.String)
  case recvFailed(Swift.String)
  case getSockNameFailed(Swift.String)
}
open class Socket : Swift.Hashable, Swift.Equatable {
  public init(socketFileDescriptor: Swift.Int32)
  @objc deinit
  public func hash(into hasher: inout Swift.Hasher)
  public func close()
  public func port() throws -> Darwin.in_port_t
  public func isIPv4() throws -> Swift.Bool
  public func writeUTF8(_ string: Swift.String) throws
  public func writeUInt8(_ data: [Swift.UInt8]) throws
  public func writeUInt8(_ data: Swift.ArraySlice<Swift.UInt8>) throws
  public func writeData(_ data: Foundation.NSData) throws
  public func writeData(_ data: Foundation.Data) throws
  open func read() throws -> Swift.UInt8
  open func read(length: Swift.Int) throws -> [Swift.UInt8]
  public func readLine() throws -> Swift.String
  public func peername() throws -> Swift.String
  public class func setNoSigPipe(_ socket: Swift.Int32)
  public class func close(_ socket: Swift.Int32)
  open var hashValue: Swift.Int {
    get
  }
}
public func == (socket1: SwarmCloudKit.Socket, socket2: SwarmCloudKit.Socket) -> Swift.Bool
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: any Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: any Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: any Swift.Error)
    case inputStreamReadFailed(error: any Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: any Swift.Error)
    case customEncodingFailed(error: any Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(SwarmCloudKit.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: any Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: any Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: any Swift.Error)
    case decodingFailed(error: any Swift.Error)
    case customSerializationFailed(error: any Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: (any Swift.Error)?)
    case defaultEvaluationFailed(output: SwarmCloudKit.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: SwarmCloudKit.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: SwarmCloudKit.AFError.ServerTrustFailureReason.Output, options: SwarmCloudKit.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: any Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: any Swift.Error)
  case createURLRequestFailed(error: any Swift.Error)
  case downloadedFileMoveFailed(error: any Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: any SwarmCloudKit.URLConvertible)
  case multipartEncodingFailed(reason: SwarmCloudKit.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: SwarmCloudKit.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: SwarmCloudKit.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: any Swift.Error)
  case requestRetryFailed(retryError: any Swift.Error, originalError: any Swift.Error)
  case responseValidationFailed(reason: SwarmCloudKit.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: SwarmCloudKit.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: SwarmCloudKit.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: (any Swift.Error)?)
  case sessionTaskFailed(error: any Swift.Error)
  case urlRequestValidationFailed(reason: SwarmCloudKit.AFError.URLRequestValidationFailureReason)
}
extension Swift.Error {
  public var asAFError: SwarmCloudKit.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> SwarmCloudKit.AFError
}
extension SwarmCloudKit.AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension SwarmCloudKit.AFError {
  public var urlConvertible: (any SwarmCloudKit.URLConvertible)? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: (any Swift.Error)? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension SwarmCloudKit.AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public enum Expiry {
  case never
  case seconds(Foundation.TimeInterval)
  case date(Foundation.Date)
  public var date: Foundation.Date {
    get
  }
  public var isExpired: Swift.Bool {
    get
  }
}
public class SyncStorage<Key, Value> where Key : Swift.Hashable {
  final public let innerStorage: SwarmCloudKit.HybridStorage<Key, Value>
  final public let serialQueue: Dispatch.DispatchQueue
  public init(storage: SwarmCloudKit.HybridStorage<Key, Value>, serialQueue: Dispatch.DispatchQueue)
  @objc deinit
}
extension SwarmCloudKit.SyncStorage : SwarmCloudKit.StorageAware {
  public var allKeys: [Key] {
    get
  }
  public var allObjects: [Value] {
    get
  }
  public func entry(forKey key: Key) throws -> SwarmCloudKit.Entry<Value>
  public func removeObject(forKey key: Key) throws
  public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil) throws
  public func removeAll() throws
  public func removeExpiredObjects() throws
  public func removeInMemoryObject(forKey key: Key) throws
}
extension SwarmCloudKit.SyncStorage {
  public func transform<U>(transformer: SwarmCloudKit.Transformer<U>) -> SwarmCloudKit.SyncStorage<Key, U>
}
extension SwarmCloudKit.OrderedDictionary : Swift.Encodable where Key : Swift.Encodable, Value : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SwarmCloudKit.OrderedDictionary : Swift.Decodable where Key : Swift.Decodable, Value : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension SwarmCloudKit.OrderedDictionary {
  @available(*, deprecated, renamed: "init(values:uniquelyKeyedBy:)", message: "Please use init(values:uniquelyKeyedBy:).")
  public init<S>(values: S, keyedBy extractKey: (Value) -> Key) where Value == S.Element, S : Swift.Sequence
  @available(*, deprecated, renamed: "init(values:uniquelyKeyedBy:)", message: "Please use init(values:uniquelyKeyedBy:).")
  public init(values: [Value], keyedBy keyPath: Swift.KeyPath<Value, Key>)
  @available(*, deprecated, renamed: "init(uniqueKeysWithValues:)", message: "Please use init(uniqueKeysWithValues:).")
  public init<S>(_ elements: S) where S : Swift.Sequence, S.Element == (key: Key, value: Value)
  @available(*, deprecated, message: "Use canInsert(key:) with the element's key instead.")
  public func canInsert(_ newElement: SwarmCloudKit.OrderedDictionary<Key, Value>.Element) -> Swift.Bool
  @available(*, deprecated, message: "Since the concrete behavior of the element movement highly depends on concrete use cases, its official support will be dropped in the future. Please use the public API for modeling a move operation instead.")
  @discardableResult
  public mutating func moveElement(forKey key: Key, to newIndex: SwarmCloudKit.OrderedDictionary<Key, Value>.Index) -> SwarmCloudKit.OrderedDictionary<Key, Value>.Index?
}
@_inheritsConvenienceInitializers open class ConsoleDestination : SwarmCloudKit.BaseDestination {
  public var useNSLog: Swift.Bool
  public var useTerminalColors: Swift.Bool {
    get
    set
  }
  override public var defaultHashValue: Swift.Int {
    get
  }
  override public init()
  override open func send(_ level: SwarmCloudKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class P2pEngine : ObjectiveC.NSObject {
  @objc public static var config: SwarmCloudKit.P2pConfig?
  @objc public static var token: Swift.String?
  @objc public static let shared: SwarmCloudKit.P2pEngine
  @objc public static func sharedInstance() -> SwarmCloudKit.P2pEngine
  @objc final public var p2pStatisticsMonitor: SwarmCloudKit.P2pStatisticsMonitor? {
    @objc get
    @objc set
  }
  @objc final public var hlsInterceptor: (any SwarmCloudKit.HlsInterceptor)? {
    @objc get
    @objc set
  }
  @objc final public var playerInteractor: (any SwarmCloudKit.PlayerInteractor)? {
    @objc get
    @objc set
  }
  @objc final public var segmentIdForHls: SwarmCloudKit.HlsSegmentIdGenerator? {
    @objc get
    @objc set
  }
  @objc public static var VERSION: Swift.String {
    @objc get
  }
  @objc final public var isConnected: Swift.Bool {
    @objc get
  }
  @objc final public var peerId: Swift.String {
    @objc get
  }
  @objc final public var servingMediaType: Swift.String? {
    @objc get
  }
  @objc final public func parseStreamUrl(_ url: Swift.String) -> Swift.String
  @objc final public func parseStreamUrl(_ url: Swift.String, videoId: Swift.String?) -> Swift.String
  @objc final public func parseStreamUrl(_ url: Swift.String, videoId: Swift.String?, mimeType: SwarmCloudKit.MimeType) -> Swift.String
  @objc public static func setup(token: Swift.String, config: SwarmCloudKit.P2pConfig? = nil)
  @objc public static func destroy()
  @objc final public func notifyPlaybackStalled()
  @objc final public func stopP2p()
  @discardableResult
  @objc final public func restartP2p() -> Swift.Bool
  @objc final public func shutdown()
  @objc final public func disableP2p()
  @objc final public func enableP2p()
  @objc final public func startLocalServer() throws
  @objc deinit
}
public typealias Parameters = [Swift.String : Any]
public protocol ParameterEncoding {
  func encode(_ urlRequest: any SwarmCloudKit.URLRequestConvertible, with parameters: SwarmCloudKit.Parameters?) throws -> Foundation.URLRequest
}
public struct URLEncoding : SwarmCloudKit.ParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SwarmCloudKit.URLEncoding.Destination, b: SwarmCloudKit.URLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    case indexInBrackets
    case custom((_ key: Swift.String, _ index: Swift.Int) -> Swift.String)
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SwarmCloudKit.URLEncoding.BoolEncoding, b: SwarmCloudKit.URLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SwarmCloudKit.URLEncoding {
    get
  }
  public static var queryString: SwarmCloudKit.URLEncoding {
    get
  }
  public static var httpBody: SwarmCloudKit.URLEncoding {
    get
  }
  public let destination: SwarmCloudKit.URLEncoding.Destination
  public let arrayEncoding: SwarmCloudKit.URLEncoding.ArrayEncoding
  public let boolEncoding: SwarmCloudKit.URLEncoding.BoolEncoding
  public init(destination: SwarmCloudKit.URLEncoding.Destination = .methodDependent, arrayEncoding: SwarmCloudKit.URLEncoding.ArrayEncoding = .brackets, boolEncoding: SwarmCloudKit.URLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: any SwarmCloudKit.URLRequestConvertible, with parameters: SwarmCloudKit.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct JSONEncoding : SwarmCloudKit.ParameterEncoding {
  public enum Error : Swift.Error {
    case invalidJSONObject
    public static func == (a: SwarmCloudKit.JSONEncoding.Error, b: SwarmCloudKit.JSONEncoding.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SwarmCloudKit.JSONEncoding {
    get
  }
  public static var prettyPrinted: SwarmCloudKit.JSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: any SwarmCloudKit.URLRequestConvertible, with parameters: SwarmCloudKit.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: any SwarmCloudKit.URLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
extension SwarmCloudKit.JSONEncoding.Error {
  public var localizedDescription: Swift.String {
    get
  }
}
public class Transformer<T> {
  public init(toData: @escaping (T) throws -> Foundation.Data, fromData: @escaping (Foundation.Data) throws -> T)
  @objc deinit
}
extension SwarmCloudKit.OrderedDictionary : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SwarmCloudKit.OrderedDictionary : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class TransformerFactory {
  public static func forData() -> SwarmCloudKit.Transformer<Foundation.Data>
  public static func forCodable<U>(ofType: U.Type) -> SwarmCloudKit.Transformer<U> where U : Swift.Decodable, U : Swift.Encodable
  @objc deinit
}
@objc public enum MimeType : Swift.Int {
  case Unknown = 0, APPLICATION_M3U8
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public class IceServer : ObjectiveC.NSObject {
  public var url: Swift.String?
  public var hostname: Swift.String?
  public var port: Swift.Int16?
  public var username: Swift.String?
  public var password: Swift.String?
  @objc public init(url: Swift.String? = nil, hostname: Swift.String? = nil, port: Swift.Int = 0, username: Swift.String? = nil, password: Swift.String? = nil)
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class defaultHlsInterceptor : ObjectiveC.NSObject, SwarmCloudKit.HlsInterceptor {
  @objc override dynamic public init()
  @objc public func interceptPlaylist(data: Foundation.Data, url: Swift.String) -> Foundation.Data
  @objc public func shouldBypassSegment(url: Swift.String) -> Swift.Bool
  @objc public func isMediaSegment(url: Swift.String) -> Swift.Bool
  @objc deinit
}
@objc @_inheritsConvenienceInitializers public class P2pConfig : ObjectiveC.NSObject {
  @objc public static func defaultConfiguration() -> SwarmCloudKit.P2pConfig
  @objc convenience override dynamic public init()
  @objc required public init(trackerZone: SwarmCloudKit.TrackerZone, p2pEnabled: Swift.Bool = true, debug: Swift.Bool = false, logLevel: SwarmCloudKit.LogLevel = .WARN, httpHeadersHls: [Swift.String : Swift.String]? = nil, hlsMediaFiles: [Swift.String] = ["mp4", "fmp4", "ts", "m4s", "m4v"], customLabel: Swift.String? = nil, localPortHls: Swift.UInt = 0, maxPeerConnections: Swift.Int = 25, maxMediaFilesInPlaylist: Swift.Int = 80, announce: Swift.String? = nil, useHttpRange: Swift.Bool = true, fastStartup: Swift.Bool = true, wifiOnly: Swift.Bool = false, sharePlaylist: Swift.Bool = false, logPersistent: Swift.Bool = false, geoIpPreflight: Swift.Bool = true, insertTagWithTimeOffset: Foundation.TimeInterval = TimeInterval.nan, downloadOnly: Swift.Bool = false, signalConfig: SwarmCloudKit.SignalConfig = SignalConfig(), dcDownloadTimeout: Foundation.TimeInterval = 4.0, httpLoadTime: Foundation.TimeInterval = 3.0, iceServers: [SwarmCloudKit.IceServer] = [IceServer(url: "stun:stun.l.google.com:19302"), IceServer(url: "stun:global.stun.twilio.com:3478?transport=udp")], useStrictHlsSegmentId: Swift.Bool = false, hlsSegmentIdGenerator: SwarmCloudKit.HlsSegmentIdGenerator? = nil, playerInteractor: (any SwarmCloudKit.PlayerInteractor)? = nil, p2pProtocolVersion: SwarmCloudKit.P2pProtocolVersion = .V8, diskCacheLimit: Swift.UInt = 2000 * 1024 * 1024, memoryCacheCountLimit: Swift.UInt = 20, mediaFileSeparator: Swift.String = ".")
  @objc public var announce: Swift.String?
  @objc public var signalConfig: SwarmCloudKit.SignalConfig
  @objc public var customLabel: Swift.String?
  @objc public var p2pEnabled: Swift.Bool
  @objc public var dcDownloadTimeout: Foundation.TimeInterval
  @objc public var httpLoadTime: Foundation.TimeInterval
  @objc public var localPortHls: Swift.UInt
  @objc public var logLevel: SwarmCloudKit.LogLevel
  @objc public var debug: Swift.Bool
  @objc public var maxPeerConnections: Swift.Int
  @objc public var useHttpRange: Swift.Bool
  @objc public var fastStartup: Swift.Bool
  @objc public var wifiOnly: Swift.Bool
  @objc public var httpHeadersHls: [Swift.String : Swift.String]?
  @objc public var sharePlaylist: Swift.Bool
  @objc public var logPersistent: Swift.Bool
  @objc public var geoIpPreflight: Swift.Bool
  @objc public var downloadOnly: Swift.Bool
  @objc public var playlistTimeOffset: Foundation.TimeInterval
  @objc public var hlsMediaFiles: [Swift.String]
  @objc public var mediaFileSeparator: Swift.String
  @objc public var trackerZone: SwarmCloudKit.TrackerZone
  @objc public var iceServers: [SwarmCloudKit.IceServer]
  @objc public var useStrictHlsSegmentId: Swift.Bool
  @objc public var hlsInterceptor: any SwarmCloudKit.HlsInterceptor
  @objc public var hlsSegmentIdGenerator: SwarmCloudKit.HlsSegmentIdGenerator?
  @objc public var playerInteractor: (any SwarmCloudKit.PlayerInteractor)?
  @objc public var maxMediaFilesInPlaylist: Swift.Int
  @objc public var diskCacheLimit: Swift.UInt
  @objc public var memoryCacheCountLimit: Swift.UInt
  @objc public var p2pProtocolVersion: SwarmCloudKit.P2pProtocolVersion
  @objc deinit
}
@objc public protocol HlsInterceptor {
  @objc optional func interceptPlaylist(data: Foundation.Data, url: Swift.String) -> Foundation.Data
  @objc optional func shouldBypassSegment(url: Swift.String) -> Swift.Bool
  @objc optional func isMediaSegment(url: Swift.String) -> Swift.Bool
}
postfix operator ++
prefix operator ++
@_hasMissingDesignatedInitializers public class StunMessage {
  public var transactionId: [Swift.UInt8] {
    get
  }
  public var type: SwarmCloudKit.StunMessageType {
    get
  }
  public var mappedAddress: SwarmCloudKit.SocketAddress? {
    get
  }
  public var responseAddress: SwarmCloudKit.SocketAddress? {
    get
  }
  public var sourceAddress: SwarmCloudKit.SocketAddress? {
    get
  }
  public var changedAddress: SwarmCloudKit.SocketAddress? {
    get
  }
  public var changeRequest: SwarmCloudKit.StunChangeRequest? {
    get
  }
  public var errorCode: SwarmCloudKit.StunErrorCode? {
    get
  }
  public func parse(_ data: [Swift.UInt8]) throws
  public func toByteData() -> [Swift.UInt8]
  @objc deinit
}
final public class HybridStorage<Key, Value> where Key : Swift.Hashable {
  public init(memoryStorage: SwarmCloudKit.MemoryStorage<Key, Value>, diskStorage: SwarmCloudKit.DiskStorage<Key, Value>?)
  @objc deinit
}
extension SwarmCloudKit.HybridStorage : SwarmCloudKit.StorageAware {
  final public var allKeys: [Key] {
    get
  }
  final public var allObjects: [Value] {
    get
  }
  final public func entry(forKey key: Key) throws -> SwarmCloudKit.Entry<Value>
  final public func removeObject(forKey key: Key) throws
  final public func removeInMemoryObject(forKey key: Key) throws
  final public func setObject(_ object: Value, forKey key: Key, expiry: SwarmCloudKit.Expiry? = nil) throws
  final public func removeAll() throws
  final public func removeExpiredObjects() throws
}
extension SwarmCloudKit.HybridStorage {
  final public func transform<U>(transformer: SwarmCloudKit.Transformer<U>) -> SwarmCloudKit.HybridStorage<Key, U>
}
extension SwarmCloudKit.HybridStorage : SwarmCloudKit.StorageObservationRegistry {
  @discardableResult
  final public func addStorageObserver<O>(_ observer: O, closure: @escaping (O, SwarmCloudKit.HybridStorage<Key, Value>, SwarmCloudKit.StorageChange<Key>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  final public func removeAllStorageObservers()
  public typealias S = SwarmCloudKit.HybridStorage<Key, Value>
}
extension SwarmCloudKit.HybridStorage : SwarmCloudKit.KeyObservationRegistry {
  @discardableResult
  final public func addObserver<O>(_ observer: O, forKey key: Key, closure: @escaping (O, SwarmCloudKit.HybridStorage<Key, Value>, SwarmCloudKit.KeyChange<Value>) -> Swift.Void) -> SwarmCloudKit.ObservationToken where O : AnyObject
  final public func removeObserver(forKey key: Key)
  final public func removeAllKeyObservers()
}
extension SwarmCloudKit.HybridStorage {
  final public var totalDiskStorageSize: Swift.Int? {
    get
  }
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension Swift.String : SwarmCloudKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URL : SwarmCloudKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension Foundation.URLComponents : SwarmCloudKit.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol URLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension SwarmCloudKit.URLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension Foundation.URLRequest : SwarmCloudKit.URLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension Foundation.URLRequest {
  public init(url: any SwarmCloudKit.URLConvertible, method: SwarmCloudKit.HTTPMethod, headers: SwarmCloudKit.HTTPHeaders? = nil) throws
}
public struct OrderedDictionarySlice<Key, Value> : Swift.RandomAccessCollection, Swift.MutableCollection where Key : Swift.Hashable {
  public typealias Base = SwarmCloudKit.OrderedDictionary<Key, Value>
  public typealias SubSequence = SwarmCloudKit.OrderedDictionarySlice<Key, Value>
  public init(base: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base, bounds: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Indices)
  public var base: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base {
    get
  }
  public let startIndex: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index
  public let endIndex: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index
  public subscript(position: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index) -> SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Element {
    get
    set(newElement)
  }
  public subscript(bounds: Swift.Range<Swift.Int>) -> SwarmCloudKit.OrderedDictionarySlice<Key, Value> {
    get
    set(newElements)
  }
  public mutating func sort(by areInIncreasingOrder: (SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Element, SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Element) throws -> Swift.Bool) rethrows
  public mutating func reverse()
  public mutating func shuffle<T>(using generator: inout T) where T : Swift.RandomNumberGenerator
  public mutating func swapAt(_ i: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index, _ j: SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index)
  public typealias Element = SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Element
  public typealias Index = SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index
  public typealias Indices = Swift.Range<SwarmCloudKit.OrderedDictionarySlice<Key, Value>.Base.Index>
  public typealias Iterator = Swift.IndexingIterator<SwarmCloudKit.OrderedDictionarySlice<Key, Value>>
}
extension Network.NWInterface.InterfaceType : Swift.CaseIterable {
  public static var allCases: [Network.NWInterface.InterfaceType]
  public typealias AllCases = [Network.NWInterface.InterfaceType]
}
public struct Deque<Element> : Swift.RandomAccessCollection, Swift.MutableCollection {
  public typealias Index = SwarmCloudKit.DequeIndex
  public var capacity: Swift.Int {
    get
  }
  public var underestimatedCount: Swift.Int {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var startIndex: SwarmCloudKit.Deque<Element>.Index {
    get
  }
  public var endIndex: SwarmCloudKit.Deque<Element>.Index {
    get
  }
  public var indices: SwarmCloudKit.Deque<Element>.Indices {
    get
  }
  public func makeIterator() -> SwarmCloudKit.Deque<Element>.Iterator
  public init()
  public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence
  public init(unsafeUninitializedCapacity: Swift.Int, initializingWith initializer: (_ buffer: inout Swift.UnsafeMutableBufferPointer<Element>, _ initializedCount: inout Swift.Int) throws -> Swift.Void) rethrows
  public subscript(position: SwarmCloudKit.Deque<Element>.Index) -> Element {
    _read
    _modify
  }
  public func formIndex(after i: inout SwarmCloudKit.Deque<Element>.Index)
  public func index(after i: SwarmCloudKit.Deque<Element>.Index) -> SwarmCloudKit.Deque<Element>.Index
  public func formIndex(before i: inout SwarmCloudKit.Deque<Element>.Index)
  public func index(before i: SwarmCloudKit.Deque<Element>.Index) -> SwarmCloudKit.Deque<Element>.Index
  public func index(_ i: SwarmCloudKit.Deque<Element>.Index, offsetBy distance: Swift.Int) -> SwarmCloudKit.Deque<Element>.Index
  public func distance(from start: SwarmCloudKit.Deque<Element>.Index, to end: SwarmCloudKit.Deque<Element>.Index) -> Swift.Int
  public mutating func reserveCapacity(_ minimumCapacity: Swift.Int)
  public mutating func append(_ newElement: Element)
  public mutating func append<S>(contentsOf newElements: S) where Element == S.Element, S : Swift.Sequence
  public mutating func prepend(_ newElement: Element)
  public mutating func prepend<S>(contentsOf newElements: S) where Element == S.Element, S : Swift.Sequence
  public mutating func popFirst() -> Element?
  public mutating func popLast() -> Element?
  @discardableResult
  public mutating func removeFirst() -> Element
  @discardableResult
  public mutating func removeLast() -> Element
  public mutating func removeFirst(_ k: Swift.Int)
  public mutating func removeLast(_ k: Swift.Int)
  public mutating func removeAll(keepingCapacity keepCapacity: Swift.Bool = false)
  public func withContiguousStorageIfAvailable<R>(_ body: (Swift.UnsafeBufferPointer<Element>) throws -> R) rethrows -> R?
  public mutating func withContiguousMutableStorageIfAvailable<R>(_ body: (inout Swift.UnsafeMutableBufferPointer<Element>) throws -> R) rethrows -> R?
  public __consuming func _copyContents(initializing buffer: Swift.UnsafeMutableBufferPointer<Element>) -> (SwarmCloudKit.Deque<Element>.Iterator, Swift.UnsafeMutableBufferPointer<Element>.Index)
  public struct Iterator : Swift.IteratorProtocol {
    @usableFromInline
    internal let _buffer: SwarmCloudKit.Deque<Element>
    @usableFromInline
    internal var _index: SwarmCloudKit.Deque<Element>.Index
    @usableFromInline
    internal let _endIndex: SwarmCloudKit.Deque<Element>.Index
    public mutating func next() -> Element?
  }
  public struct Indices : Swift.RandomAccessCollection {
    public typealias Index = SwarmCloudKit.Deque<Element>.Index
    public let startIndex: SwarmCloudKit.Deque<Element>.Indices.Index
    public let endIndex: SwarmCloudKit.Deque<Element>.Indices.Index
    public func formIndex(after i: inout SwarmCloudKit.Deque<Element>.Indices.Index)
    public func index(after i: SwarmCloudKit.Deque<Element>.Indices.Index) -> SwarmCloudKit.Deque<Element>.Indices.Index
    public func formIndex(before i: inout SwarmCloudKit.Deque<Element>.Indices.Index)
    public func index(before i: SwarmCloudKit.Deque<Element>.Indices.Index) -> SwarmCloudKit.Deque<Element>.Indices.Index
    public func index(_ i: SwarmCloudKit.Deque<Element>.Indices.Index, offsetBy distance: Swift.Int) -> SwarmCloudKit.Deque<Element>.Indices.Index
    public func distance(from start: SwarmCloudKit.Deque<Element>.Indices.Index, to end: SwarmCloudKit.Deque<Element>.Indices.Index) -> Swift.Int
    public subscript(position: SwarmCloudKit.Deque<Element>.Indices.Index) -> SwarmCloudKit.Deque<Element>.Indices.Index {
      get
    }
    public subscript(bounds: Swift.Range<SwarmCloudKit.Deque<Element>.Indices.Index>) -> SwarmCloudKit.Deque<Element>.Indices {
      get
    }
    @usableFromInline
    internal let _header: SwarmCloudKit._DequeHeader
    public typealias Indices = Swift.DefaultIndices<SwarmCloudKit.Deque<Element>.Indices>
    public typealias Iterator = Swift.IndexingIterator<SwarmCloudKit.Deque<Element>.Indices>
    public typealias SubSequence = SwarmCloudKit.Deque<Element>.Indices
  }
  @usableFromInline
  internal var _storage: Swift.ManagedBufferPointer<SwarmCloudKit._DequeHeader, Element>
  @_hasMissingDesignatedInitializers @usableFromInline
  final internal class _Storage {
    @usableFromInline
    internal typealias Manager = Swift.ManagedBufferPointer<SwarmCloudKit._DequeHeader, Element>
    @objc deinit
  }
  public typealias SubSequence = Swift.Slice<SwarmCloudKit.Deque<Element>>
}
public struct DequeIndex : Swift.Comparable, Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public static func < (lhs: SwarmCloudKit.DequeIndex, rhs: SwarmCloudKit.DequeIndex) -> Swift.Bool
  @usableFromInline
  internal var _rawValue: Swift.UInt
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public static func == (a: SwarmCloudKit.DequeIndex, b: SwarmCloudKit.DequeIndex) -> Swift.Bool
}
extension SwarmCloudKit.Deque : Swift.Equatable where Element : Swift.Equatable {
  public static func == (lhs: SwarmCloudKit.Deque<Element>, rhs: SwarmCloudKit.Deque<Element>) -> Swift.Bool
}
extension SwarmCloudKit.Deque : Swift.Hashable where Element : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension SwarmCloudKit.Deque : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SwarmCloudKit.Deque : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SwarmCloudKit.Deque : Swift.CustomReflectable {
  public var customMirror: Swift.Mirror {
    get
  }
}
extension SwarmCloudKit.Deque : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: Element...)
  public typealias ArrayLiteralElement = Element
}
extension SwarmCloudKit.Deque : Swift.Encodable where Element : Swift.Encodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension SwarmCloudKit.Deque : Swift.Decodable where Element : Swift.Decodable {
  public init(from decoder: any Swift.Decoder) throws
}
@usableFromInline
internal struct _DequeHeader {
  @usableFromInline
  internal var capacity: Swift.Int
  @usableFromInline
  internal var headSpan: Swift.Range<Swift.Int>
  @usableFromInline
  internal var tailCount: Swift.Int
  @usableFromInline
  internal typealias Index = SwarmCloudKit.DequeIndex
}
@_hasMissingDesignatedInitializers @usableFromInline
final internal class _DequeEmptyStorage {
  @usableFromInline
  internal static var shared: SwarmCloudKit._DequeEmptyStorage
  @objc deinit
}
extension SwarmCloudKit.Request {
  public typealias ValidationResult = Swift.Result<Swift.Void, any Swift.Error>
}
extension SwarmCloudKit.DataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> SwarmCloudKit.DataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension SwarmCloudKit.DataStreamRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse) -> SwarmCloudKit.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension SwarmCloudKit.DownloadRequest {
  public typealias Validation = (_ request: Foundation.URLRequest?, _ response: Foundation.HTTPURLResponse, _ fileURL: Foundation.URL?) -> SwarmCloudKit.DownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
public struct Entry<T> {
  public let object: T
  public let expiry: SwarmCloudKit.Expiry
  public let filePath: Swift.String?
}
@objc public enum LogLevel : Swift.Int {
  case VERBOSE = 2
  case DEBUG = 3
  case INFO = 4
  case WARN = 5
  case ERROR = 6
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: SwarmCloudKit.Redirector
  public static let doNotFollow: SwarmCloudKit.Redirector
  public let behavior: SwarmCloudKit.Redirector.Behavior
  public init(behavior: SwarmCloudKit.Redirector.Behavior)
}
extension SwarmCloudKit.Redirector : SwarmCloudKit.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
extension SwarmCloudKit.RedirectHandler where Self == SwarmCloudKit.Redirector {
  public static var follow: SwarmCloudKit.Redirector {
    get
  }
  public static var doNotFollow: SwarmCloudKit.Redirector {
    get
  }
  public static func modify(using closure: @escaping (Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?) -> SwarmCloudKit.Redirector
}
open class SwiftTimer {
  final public let repeats: Swift.Bool
  public typealias SwiftTimerHandler = (SwarmCloudKit.SwiftTimer) -> Swift.Void
  public init(interval: Dispatch.DispatchTimeInterval, repeats: Swift.Bool = false, leeway: Dispatch.DispatchTimeInterval = .seconds(0), queue: Dispatch.DispatchQueue = .main, handler: @escaping SwarmCloudKit.SwiftTimer.SwiftTimerHandler)
  public static func repeaticTimer(interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .seconds(0), queue: Dispatch.DispatchQueue = .main, handler: @escaping SwarmCloudKit.SwiftTimer.SwiftTimerHandler) -> SwarmCloudKit.SwiftTimer
  @objc deinit
  public func fire()
  public func start()
  public func suspend()
  public func rescheduleRepeating(interval: Dispatch.DispatchTimeInterval)
  public func rescheduleHandler(handler: @escaping SwarmCloudKit.SwiftTimer.SwiftTimerHandler)
}
extension SwarmCloudKit.SwiftTimer {
  public static func debounce(interval: Dispatch.DispatchTimeInterval, identifier: Swift.String, queue: Dispatch.DispatchQueue = .main, handler: @escaping () -> Swift.Void)
  public static func throttle(interval: Dispatch.DispatchTimeInterval, identifier: Swift.String, queue: Dispatch.DispatchQueue = .main, handler: @escaping () -> Swift.Void)
  public static func cancelThrottlingTimer(identifier: Swift.String)
}
public class SwiftCountDownTimer {
  public init(interval: Dispatch.DispatchTimeInterval, times: Swift.Int, queue: Dispatch.DispatchQueue = .main, handler: @escaping (SwarmCloudKit.SwiftCountDownTimer, _ leftTimes: Swift.Int) -> Swift.Void)
  public func start()
  public func suspend()
  public func reCountDown()
  @objc deinit
}
extension Dispatch.DispatchTimeInterval {
  public static func fromSeconds(_ seconds: Swift.Double) -> Dispatch.DispatchTimeInterval
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SwarmCloudKit.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SwarmCloudKit.ResponseSerializer
  public init<Serializer>(_ request: SwarmCloudKit.DataRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SwarmCloudKit.DataResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SwarmCloudKit.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SwarmCloudKit.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension SwarmCloudKit.DataResponsePublisher where Value == Foundation.Data? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: SwarmCloudKit.DataRequest, queue: Dispatch.DispatchQueue)
}
extension SwarmCloudKit.DataRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DataResponsePublisher<T> where Serializer : SwarmCloudKit.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DataResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DataResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SwarmCloudKit.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SwarmCloudKit.DataResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DataResponsePublisher<Foundation.Data?>
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DataStreamPublisher<Value> : Combine.Publisher {
  public typealias Output = SwarmCloudKit.DataStreamRequest.Stream<Value, SwarmCloudKit.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SwarmCloudKit.DataStreamRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SwarmCloudKit.DataStreamSerializer
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SwarmCloudKit.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SwarmCloudKit.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == SwarmCloudKit.DataStreamRequest.Stream<Value, SwarmCloudKit.AFError>
}
extension SwarmCloudKit.DataStreamRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DataStreamPublisher<Serializer.SerializedObject> where Serializer : SwarmCloudKit.DataStreamSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishData(queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DataStreamPublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishString(queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DataStreamPublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  final public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), preprocessor: any SwarmCloudKit.DataPreprocessor = PassthroughPreprocessor()) -> SwarmCloudKit.DataStreamPublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
public struct DownloadResponsePublisher<Value> : Combine.Publisher {
  public typealias Output = SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError>
  public typealias Failure = Swift.Never
  public init<Serializer>(_ request: SwarmCloudKit.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SwarmCloudKit.ResponseSerializer
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init<Serializer>(_ request: SwarmCloudKit.DownloadRequest, queue: Dispatch.DispatchQueue, serializer: Serializer) where Value == Serializer.SerializedObject, Serializer : SwarmCloudKit.DownloadResponseSerializerProtocol
  public func result() -> Combine.AnyPublisher<Swift.Result<Value, SwarmCloudKit.AFError>, Swift.Never>
  public func value() -> Combine.AnyPublisher<Value, SwarmCloudKit.AFError>
  public func receive<S>(subscriber: S) where S : Combine.Subscriber, S.Failure == Swift.Never, S.Input == SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError>
}
extension SwarmCloudKit.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DownloadResponsePublisher<T> where Serializer : SwarmCloudKit.ResponseSerializer, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishResponse<Serializer, T>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DownloadResponsePublisher<T> where Serializer : SwarmCloudKit.DownloadResponseSerializerProtocol, T == Serializer.SerializedObject
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishURL(queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DownloadResponsePublisher<Foundation.URL>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishData(queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadResponsePublisher<Foundation.Data>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishString(queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadResponsePublisher<Swift.String>
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  @available(*, deprecated, message: "Renamed publishDecodable(type:queue:preprocessor:decoder:emptyResponseCodes:emptyRequestMethods).")
  @_disfavoredOverload public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyResponseMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadResponsePublisher<T> where T : Swift.Decodable
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishDecodable<T>(type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, preprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadResponsePublisher<T> where T : Swift.Decodable
}
@available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
extension SwarmCloudKit.DownloadResponsePublisher where Value == Foundation.URL? {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public init(_ request: SwarmCloudKit.DownloadRequest, queue: Dispatch.DispatchQueue)
}
extension SwarmCloudKit.DownloadRequest {
  @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  public func publishUnserialized(on queue: Dispatch.DispatchQueue = .main) -> SwarmCloudKit.DownloadResponsePublisher<Foundation.URL?>
}
public enum ExpirationMode {
  case auto, manual
  public static func == (a: SwarmCloudKit.ExpirationMode, b: SwarmCloudKit.ExpirationMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc open class P2pStatisticsMonitor : ObjectiveC.NSObject {
  @objc public init(queue: Dispatch.DispatchQueue = .main)
  final public let queue: Dispatch.DispatchQueue
  @objc open var onHttpDownloaded: ((_ value: Swift.Int) -> Swift.Void)?
  @objc open var onP2pDownloaded: ((_ value: Swift.Int, _ speed: Swift.Int) -> Swift.Void)?
  @objc open var onP2pUploaded: ((_ value: Swift.Int) -> Swift.Void)?
  @objc open var onPeers: ((_ peers: [Swift.String]) -> Swift.Void)?
  @objc open var onServerConnected: ((_ connected: Swift.Bool) -> Swift.Void)?
  @objc deinit
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.Request {
  #if compiler(>=5.3) && $RethrowsProtocol
  public func uploadProgress(bufferingPolicy: SwarmCloudKit.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> SwarmCloudKit.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func downloadProgress(bufferingPolicy: SwarmCloudKit.StreamOf<Foundation.Progress>.BufferingPolicy = .unbounded) -> SwarmCloudKit.StreamOf<Foundation.Progress>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlRequests(bufferingPolicy: SwarmCloudKit.StreamOf<Foundation.URLRequest>.BufferingPolicy = .unbounded) -> SwarmCloudKit.StreamOf<Foundation.URLRequest>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func urlSessionTasks(bufferingPolicy: SwarmCloudKit.StreamOf<Foundation.URLSessionTask>.BufferingPolicy = .unbounded) -> SwarmCloudKit.StreamOf<Foundation.URLSessionTask>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func cURLDescriptions(bufferingPolicy: SwarmCloudKit.StreamOf<Swift.String>.BufferingPolicy = .unbounded) -> SwarmCloudKit.StreamOf<Swift.String>
  #endif
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: SwarmCloudKit.DataResponse<Value, SwarmCloudKit.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, SwarmCloudKit.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.DataRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DataTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> SwarmCloudKit.DataTask<Value> where Value : Swift.Decodable
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DataTask<Swift.String>
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> SwarmCloudKit.DataTask<Serializer.SerializedObject> where Serializer : SwarmCloudKit.ResponseSerializer
  public func serializingResponse<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> SwarmCloudKit.DataTask<Serializer.SerializedObject> where Serializer : SwarmCloudKit.DataResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DownloadTask<Value> {
  #if compiler(>=5.3) && $EffectfulProp
  public var response: SwarmCloudKit.DownloadResponse<Value, SwarmCloudKit.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var result: Swift.Result<Value, SwarmCloudKit.AFError> {
    get async
  }
  #endif
  #if compiler(>=5.3) && $EffectfulProp
  public var value: Value {
    get async throws
  }
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.DownloadRequest {
  public func serializingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadTask<Foundation.Data>
  public func serializingDecodable<Value>(_ type: Value.Type = Value.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = DecodableResponseSerializer<Value>.defaultDataPreprocessor, decoder: any SwarmCloudKit.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<Value>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = DecodableResponseSerializer<Value>.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadTask<Value> where Value : Swift.Decodable
  public func serializingDownloadedFileURL(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> SwarmCloudKit.DownloadTask<Foundation.URL>
  public func serializingString(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false, dataPreprocessor: any SwarmCloudKit.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SwarmCloudKit.HTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods) -> SwarmCloudKit.DownloadTask<Swift.String>
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> SwarmCloudKit.DownloadTask<Serializer.SerializedObject> where Serializer : SwarmCloudKit.ResponseSerializer
  public func serializingDownload<Serializer>(using serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = false) -> SwarmCloudKit.DownloadTask<Serializer.SerializedObject> where Serializer : SwarmCloudKit.DownloadResponseSerializerProtocol
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct DataStreamTask {
  #if compiler(>=5.3) && $RethrowsProtocol
  public typealias Stream<Success, Failure> = SwarmCloudKit.StreamOf<SwarmCloudKit.DataStreamRequest.Stream<Success, Failure>> where Failure : Swift.Error
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingData(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: SwarmCloudKit.DataStreamTask.Stream<Foundation.Data, Swift.Never>.BufferingPolicy = .unbounded) -> SwarmCloudKit.DataStreamTask.Stream<Foundation.Data, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingStrings(automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: SwarmCloudKit.DataStreamTask.Stream<Swift.String, Swift.Never>.BufferingPolicy = .unbounded) -> SwarmCloudKit.DataStreamTask.Stream<Swift.String, Swift.Never>
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingDecodables<T>(_ type: T.Type = T.self, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: SwarmCloudKit.DataStreamTask.Stream<T, SwarmCloudKit.AFError>.BufferingPolicy = .unbounded) -> SwarmCloudKit.DataStreamTask.Stream<T, SwarmCloudKit.AFError> where T : Swift.Decodable
  #endif
  #if compiler(>=5.3) && $RethrowsProtocol
  public func streamingResponses<Serializer>(serializedUsing serializer: Serializer, automaticallyCancelling shouldAutomaticallyCancel: Swift.Bool = true, bufferingPolicy: SwarmCloudKit.DataStreamTask.Stream<Serializer.SerializedObject, SwarmCloudKit.AFError>.BufferingPolicy = .unbounded) -> SwarmCloudKit.DataStreamTask.Stream<Serializer.SerializedObject, SwarmCloudKit.AFError> where Serializer : SwarmCloudKit.DataStreamSerializer
  #endif
  public func cancel()
  public func resume()
  public func suspend()
}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.DataStreamRequest {
  final public func streamTask() -> SwarmCloudKit.DataStreamTask
}
#if compiler(>=5.3) && $RethrowsProtocol
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
public struct StreamOf<Element> : _Concurrency.AsyncSequence {
  public typealias AsyncIterator = SwarmCloudKit.StreamOf<Element>.Iterator
  public typealias BufferingPolicy = _Concurrency.AsyncStream<Element>.Continuation.BufferingPolicy
  public func makeAsyncIterator() -> SwarmCloudKit.StreamOf<Element>.Iterator
  public struct Iterator : _Concurrency.AsyncIteratorProtocol {
    #if compiler(>=5.3) && $AsyncAwait
    public mutating func next() async -> Element?
    #endif
  }
}
#endif
open class HlsPlaylist {
  open var url: Swift.String?
  public init()
  @objc deinit
}
public typealias AFDataResponse<Success> = SwarmCloudKit.DataResponse<Success, SwarmCloudKit.AFError>
public typealias AFDownloadResponse<Success> = SwarmCloudKit.DownloadResponse<Success, SwarmCloudKit.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension SwarmCloudKit.DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SwarmCloudKit.DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SwarmCloudKit.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SwarmCloudKit.DataResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SwarmCloudKit.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SwarmCloudKit.DataResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension SwarmCloudKit.DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension SwarmCloudKit.DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SwarmCloudKit.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SwarmCloudKit.DownloadResponse<NewSuccess, any Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SwarmCloudKit.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SwarmCloudKit.DownloadResponse<Success, any Swift.Error> where NewFailure : Swift.Error
}
public enum P2pEngineError : Swift.Error {
  case TrackerError(reason: Swift.String)
  case SignalingError(reason: Swift.String)
  case SchedulerError(reason: Swift.String)
  case OtherError(reason: Swift.String)
}
public let AF: SwarmCloudKit.Session
public protocol HttpServerIODelegate : AnyObject {
  func socketConnectionReceived(_ socket: SwarmCloudKit.Socket)
}
@_hasMissingDesignatedInitializers open class HttpServerIO {
  weak public var delegate: (any SwarmCloudKit.HttpServerIODelegate)?
  public enum HttpServerIOState : Swift.Int32 {
    case starting
    case running
    case stopping
    case stopped
    public init?(rawValue: Swift.Int32)
    public typealias RawValue = Swift.Int32
    public var rawValue: Swift.Int32 {
      get
    }
  }
  public var state: SwarmCloudKit.HttpServerIO.HttpServerIOState {
    get
  }
  public var operating: Swift.Bool {
    get
  }
  public var listenAddressIPv4: Swift.String?
  public var listenAddressIPv6: Swift.String?
  public func port() throws -> Swift.Int
  public func isIPv4() throws -> Swift.Bool
  @objc deinit
  @available(macOS 10.10, *)
  public func start(_ port: Darwin.in_port_t = 8080, forceIPv4: Swift.Bool = false, priority: Dispatch.DispatchQoS.QoSClass = DispatchQoS.QoSClass.background) throws
  public func stop()
  open func dispatch(_ request: SwarmCloudKit.HttpRequest) -> ([Swift.String : Swift.String], (SwarmCloudKit.HttpRequest) -> SwarmCloudKit.HttpResponse)
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: SwarmCloudKit.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: SwarmCloudKit.AlamofireExtension<Self.ExtendedType> { get set }
}
extension SwarmCloudKit.AlamofireExtended {
  public static var af: SwarmCloudKit.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: SwarmCloudKit.AlamofireExtension<Self> {
    get
    set
  }
}
extension Swift.Dictionary {
  public func sorted(by areInIncreasingOrder: (Swift.Dictionary<Key, Value>.Element, Swift.Dictionary<Key, Value>.Element) throws -> Swift.Bool) rethrows -> SwarmCloudKit.OrderedDictionary<Key, Value>
}
extension SwarmCloudKit.JSON {
  public func decodeObjcet<T>(_ type: T.Type) -> T? where T : Swift.Decodable
}
extension Swift.Encodable {
  public func toJson() -> Swift.String
}
public struct OrderedSet<T> where T : Swift.Hashable {
  public init()
  public init<S>(sequence: S) where T == S.Element, S : Swift.Sequence
  public init(arrayLiteral elements: T...)
  public func index(of object: T) -> SwarmCloudKit.OrderedSet<T>.Index?
  public mutating func append(_ object: T)
  public mutating func append<S>(contentsOf sequence: S) where T == S.Element, S : Swift.Sequence
  @discardableResult
  public mutating func remove(_ object: T) -> SwarmCloudKit.OrderedSet<T>.Index?
  @discardableResult
  public mutating func remove<S>(_ objects: S) -> [SwarmCloudKit.OrderedSet<T>.Index]? where T == S.Element, S : Swift.Sequence
  public mutating func removeObject(at index: SwarmCloudKit.OrderedSet<T>.Index)
  @discardableResult
  public mutating func removeAllObjects(where shouldBeRemoved: (T) -> Swift.Bool) -> SwarmCloudKit.OrderedSet<T>
  public mutating func removeAllObjects()
  public mutating func swapObject(_ first: T, with second: T)
  public func intersects<S>(_ other: S) -> Swift.Bool where T == S.Element, S : Swift.Sequence
  public func isSubset<S>(of sequence: S) -> Swift.Bool where T == S.Element, S : Swift.Sequence
  public mutating func moveObject(_ object: T, toIndex index: SwarmCloudKit.OrderedSet<T>.Index)
  public mutating func moveObject(at index: SwarmCloudKit.OrderedSet<T>.Index, to toIndex: SwarmCloudKit.OrderedSet<T>.Index)
  public mutating func insert(_ object: T, at index: SwarmCloudKit.OrderedSet<T>.Index)
  public mutating func insert<S>(_ objects: S, at index: SwarmCloudKit.OrderedSet<T>.Index) where T == S.Element, S : Swift.Sequence
  public var last: T? {
    get
  }
}
extension SwarmCloudKit.OrderedSet : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = T
}
extension SwarmCloudKit.OrderedSet {
  public var elements: [T] {
    get
  }
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var first: T? {
    get
  }
  public func index(after index: Swift.Int) -> Swift.Int
  public typealias Index = Swift.Int
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: SwarmCloudKit.OrderedSet<T>.Index) -> T {
    get
    set
  }
}
public func + <T, S>(lhs: SwarmCloudKit.OrderedSet<T>, rhs: S) -> SwarmCloudKit.OrderedSet<T> where T : Swift.Hashable, T == S.Element, S : Swift.Sequence
public func += <T, S>(lhs: inout SwarmCloudKit.OrderedSet<T>, rhs: S) where T : Swift.Hashable, T == S.Element, S : Swift.Sequence
public func - <T, S>(lhs: SwarmCloudKit.OrderedSet<T>, rhs: S) -> SwarmCloudKit.OrderedSet<T> where T : Swift.Hashable, T == S.Element, S : Swift.Sequence
public func -= <T, S>(lhs: inout SwarmCloudKit.OrderedSet<T>, rhs: S) where T : Swift.Hashable, T == S.Element, S : Swift.Sequence
extension SwarmCloudKit.OrderedSet : Swift.Equatable {
}
public func == <T>(lhs: SwarmCloudKit.OrderedSet<T>, rhs: SwarmCloudKit.OrderedSet<T>) -> Swift.Bool where T : Swift.Hashable
extension SwarmCloudKit.OrderedSet : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SwarmCloudKit.OrderedSet : Swift.RandomAccessCollection {
  public typealias Element = T
  public typealias Indices = Swift.Range<SwarmCloudKit.OrderedSet<T>.Index>
  public typealias Iterator = Swift.IndexingIterator<SwarmCloudKit.OrderedSet<T>>
  public typealias SubSequence = Swift.Slice<SwarmCloudKit.OrderedSet<T>>
}
@_hasMissingDesignatedInitializers public class Errno {
  public class func description() -> Swift.String
  @objc deinit
}
public struct HTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: SwarmCloudKit.HTTPMethod
  public static let delete: SwarmCloudKit.HTTPMethod
  public static let get: SwarmCloudKit.HTTPMethod
  public static let head: SwarmCloudKit.HTTPMethod
  public static let options: SwarmCloudKit.HTTPMethod
  public static let patch: SwarmCloudKit.HTTPMethod
  public static let post: SwarmCloudKit.HTTPMethod
  public static let put: SwarmCloudKit.HTTPMethod
  public static let query: SwarmCloudKit.HTTPMethod
  public static let trace: SwarmCloudKit.HTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
extension SwarmCloudKit.Socket {
  public class func tcpSocketForListen(_ port: Darwin.in_port_t, _ forceIPv4: Swift.Bool = false, _ maxPendingConnection: Swift.Int32 = SOMAXCONN, _ listenAddress: Swift.String? = nil) throws -> SwarmCloudKit.Socket
  public func acceptClientSocket() throws -> SwarmCloudKit.Socket
}
@_hasMissingDesignatedInitializers @available(iOS 12.0, macOS 10.14, tvOS 12.0, *)
public class StunClient {
  public static func query(localIP: Swift.String) -> SwarmCloudKit.StunResult
  public static func query(stunHost: Swift.String, stunPort: Swift.Int, localIP: Swift.String) -> SwarmCloudKit.StunResult
  @objc deinit
}
@_inheritsConvenienceInitializers open class MediaPlaylist : SwarmCloudKit.HlsPlaylist {
  open var programId: Swift.Int
  open var bandwidth: Swift.Int
  open var path: Swift.String?
  open var version: Swift.Int?
  open var targetDuration: Swift.Int?
  open var mediaSequence: Swift.Int
  open var endSN: Swift.Int {
    get
  }
  open var hasEndTag: Swift.Bool
  override public init()
  open func getSegmentCount() -> Swift.Int
  open func duration() -> Swift.Float
  open func getMaster() -> SwarmCloudKit.MasterPlaylist?
  @objc deinit
}
extension SwarmCloudKit.MediaPlaylist : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
open class HlsManifestBuilder {
  public init()
  open func parse(_ string: Swift.String, _ baseUri: Foundation.URL, level: Swift.Int = 0) -> SwarmCloudKit.HlsPlaylist?
  open func parseMasterPlaylistFromString(_ string: Swift.String, _ baseUri: Foundation.URL) -> SwarmCloudKit.MasterPlaylist
  open func parseMediaPlaylistFromString(_ string: Swift.String, _ baseUri: Foundation.URL, level: Swift.Int = 0) -> SwarmCloudKit.MediaPlaylist
  @objc deinit
}
extension Foundation.URLSessionConfiguration : SwarmCloudKit.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension SwarmCloudKit.AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
  public static var ephemeral: Foundation.URLSessionConfiguration {
    get
  }
}
public enum NatType : Swift.String {
  case UdpBlocked
  case OpenInternet
  case SymmetricUdpFirewall
  case FullCone
  case RestrictedCone
  case PortRestrictedCone
  case Symmetric
  case Unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers @available(iOS 12.0, macOS 10.14, tvOS 12.0, *)
public class UdpSocket {
  @objc deinit
}
extension Foundation.URLRequest {
  public var method: SwarmCloudKit.HTTPMethod? {
    get
    set
  }
  public func validate() throws
}
open class FileDestination : SwarmCloudKit.BaseDestination {
  public var logFileURL: Foundation.URL?
  public var syncAfterEachWrite: Swift.Bool
  public var colored: Swift.Bool {
    get
    set
  }
  public var logFileMaxSize: (Swift.Int)
  public var logFileAmount: Swift.Int
  override public var defaultHashValue: Swift.Int {
    get
  }
  public init(logFileURL: Foundation.URL? = nil)
  override open func send(_ level: SwarmCloudKit.SwiftyBeaver.Level, msg: Swift.String, thread: Swift.String, file: Swift.String, function: Swift.String, line: Swift.Int, context: Any? = nil) -> Swift.String?
  public func deleteLogFile() -> Swift.Bool
  @objc deinit
}
public typealias AFResult<Success> = Swift.Result<Success, SwarmCloudKit.AFError>
extension SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension SwarmCloudKit.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension SwarmCloudKit.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension SwarmCloudKit.SerializationError : Swift.Equatable {}
extension SwarmCloudKit.SerializationError : Swift.Hashable {}
extension SwarmCloudKit.TrackerZone : Swift.Equatable {}
extension SwarmCloudKit.TrackerZone : Swift.Hashable {}
extension SwarmCloudKit.TrackerZone : Swift.RawRepresentable {}
extension SwarmCloudKit.StorageError : Swift.Equatable {}
extension SwarmCloudKit.StorageError : Swift.Hashable {}
extension SwarmCloudKit.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension SwarmCloudKit.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Equatable {}
@available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
extension SwarmCloudKit.DeflateRequestCompressor.DuplicateHeaderBehavior : Swift.Hashable {}
extension SwarmCloudKit.JSONDictionaryWrapper.CodingKeys : Swift.Equatable {}
extension SwarmCloudKit.JSONDictionaryWrapper.CodingKeys : Swift.Hashable {}
extension SwarmCloudKit.JSONDictionaryWrapper.CodingKeys : Swift.RawRepresentable {}
extension SwarmCloudKit.StunMessageType : Swift.Equatable {}
extension SwarmCloudKit.StunMessageType : Swift.Hashable {}
extension SwarmCloudKit.StunMessageType : Swift.RawRepresentable {}
extension SwarmCloudKit.Request.State : Swift.Equatable {}
extension SwarmCloudKit.Request.State : Swift.Hashable {}
extension SwarmCloudKit.JSONArrayWrapper.CodingKeys : Swift.Equatable {}
extension SwarmCloudKit.JSONArrayWrapper.CodingKeys : Swift.Hashable {}
extension SwarmCloudKit.JSONArrayWrapper.CodingKeys : Swift.RawRepresentable {}
extension SwarmCloudKit.SwiftyJSONError : Swift.Equatable {}
extension SwarmCloudKit.SwiftyJSONError : Swift.Hashable {}
extension SwarmCloudKit.SwiftyJSONError : Swift.RawRepresentable {}
extension SwarmCloudKit.`Type` : Swift.Equatable {}
extension SwarmCloudKit.`Type` : Swift.Hashable {}
extension SwarmCloudKit.`Type` : Swift.RawRepresentable {}
extension SwarmCloudKit.writingOptionsKeys : Swift.Equatable {}
extension SwarmCloudKit.writingOptionsKeys : Swift.Hashable {}
extension SwarmCloudKit.AuthenticationError : Swift.Equatable {}
extension SwarmCloudKit.AuthenticationError : Swift.Hashable {}
extension SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension SwarmCloudKit.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension SwarmCloudKit.P2pProtocolVersion : Swift.Equatable {}
extension SwarmCloudKit.P2pProtocolVersion : Swift.Hashable {}
extension SwarmCloudKit.P2pProtocolVersion : Swift.RawRepresentable {}
extension SwarmCloudKit.SwiftyBeaver.Level : Swift.Equatable {}
extension SwarmCloudKit.SwiftyBeaver.Level : Swift.Hashable {}
extension SwarmCloudKit.SwiftyBeaver.Level : Swift.RawRepresentable {}
extension SwarmCloudKit.URLEncoding.Destination : Swift.Equatable {}
extension SwarmCloudKit.URLEncoding.Destination : Swift.Hashable {}
extension SwarmCloudKit.URLEncoding.BoolEncoding : Swift.Equatable {}
extension SwarmCloudKit.URLEncoding.BoolEncoding : Swift.Hashable {}
extension SwarmCloudKit.JSONEncoding.Error : Swift.Equatable {}
extension SwarmCloudKit.JSONEncoding.Error : Swift.Hashable {}
extension SwarmCloudKit.MimeType : Swift.Equatable {}
extension SwarmCloudKit.MimeType : Swift.Hashable {}
extension SwarmCloudKit.MimeType : Swift.RawRepresentable {}
extension SwarmCloudKit.LogLevel : Swift.Equatable {}
extension SwarmCloudKit.LogLevel : Swift.Hashable {}
extension SwarmCloudKit.LogLevel : Swift.RawRepresentable {}
extension SwarmCloudKit.ExpirationMode : Swift.Equatable {}
extension SwarmCloudKit.ExpirationMode : Swift.Hashable {}
extension SwarmCloudKit.HttpServerIO.HttpServerIOState : Swift.Equatable {}
extension SwarmCloudKit.HttpServerIO.HttpServerIOState : Swift.Hashable {}
extension SwarmCloudKit.HttpServerIO.HttpServerIOState : Swift.RawRepresentable {}
extension SwarmCloudKit.NatType : Swift.Equatable {}
extension SwarmCloudKit.NatType : Swift.Hashable {}
extension SwarmCloudKit.NatType : Swift.RawRepresentable {}
